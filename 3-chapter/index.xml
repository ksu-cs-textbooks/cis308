<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pointers and Dynamic Memory :: CIS 308 Textbook</title><link>https://textbooks.cs.ksu.edu/cis308/3-chapter/index.html</link><description/><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 30 Nov 2022 15:23:02 -0600</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cis308/3-chapter/index.xml" rel="self" type="application/rss+xml"/><item><title>Pointers</title><link>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_1-pointers/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_1-pointers/index.html</guid><description>Pointers in C are variables that store the memory address of some other variable or data. They have an associated type of what kind of value they reference.
Pointers are one of the most difficult concepts in the C language. However, mastering pointers allows you do have a deeper understanding of what actually happens when your program runs. Higher-level languages do not explicitly use pointers, but they do use pointers “behind the scenes”. Learning pointers in C can also help you understand what’s going on in Java/C#/etc. programs.</description></item><item><title>Pointers vs. Arrays</title><link>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_2-pointersvsarrays/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_2-pointersvsarrays/index.html</guid><description>Arrays and pointers have a lot in common. When we do:
int nums[10]; Then we get a spot in memory that looks like this:
But what is nums? It is actually a constant pointer to the first spot in the array, nums[0]. So really, the picture looks like this:</description></item><item><title>Iteration with Pointers</title><link>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_3-interationwithpointers/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_3-interationwithpointers/index.html</guid><description>This is how we have initialized array elements in the past:
int i; int nums[10]; for (i = 0; i &lt; 10; i++) { nums[i] = 0; } However, now that we can treat arrays like pointers, there is a different way to initialize array elements:
int *ip; int nums[10]; for (ip = nums; ip &lt; nums+10; ip++) { *ip = 0; } Here, ip is a pointer that starts by pointing to the first element in the array. We loop while the value of ip (the memory address) is less than nums+10 – which is the address of the last element in the array. Each time, ip++ advances ip to point at the next element in the array. Inside the loop, we dereference ip to get the current array element, and set that element to 0.</description></item><item><title>Pointers to Pointers</title><link>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_4-pointerstopointers/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_4-pointerstopointers/index.html</guid><description>Just like a variable can be a pointer, we can also declare pointers to pointers. (We can take it even further than that, but it starts to get pretty confusing!) You can denote the “level” of the pointer by how many *’s you use in the declaration.
Here’s an example of using pointers to pointers:
int i; //declares the int i int *ip; //declares the int pointer ip int **ipp; //declares a pointer to a pointer to an int, ipp i = 36; //gives i the value 36 ip = &amp;i; //now ip points to i *ip = 72; //dereferences ip to get i, and sets it to 72 (now i=72) ipp = &amp;ip; //ipp points to ip, which points to i **ipp = 24; //dereferences ipp to get ip, then dereferences again to get i, //and sets it to 24 (now i = 24)</description></item><item><title>Call by Reference</title><link>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_5-callbyreference/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_5-callbyreference/index.html</guid><description>C functions are naturally call-by-value, which means that we don’t pass variables themselves – we pass their value. So, if we modify one of the parameters in our function, it does not modify the original variable passed to the function. Consider the following example:
//This example doesn’t work! void swap(int a, int b) { int temp = a; a = b; b = temp; } //assume the test code below is in another function int x = 3; int y = 4; swap(x, y); This code fragment is supposed to swap the values in x and y, so that x == 4 and y == 3. However, when we call swap, only the VALUES 3 and 4 are passed – not x and y themselves. The values 3 and 4 get bound to the function parameters a and b. By the end of the function, we do have that a == 4 and b == 3. However, x and y don’t change because they are completely different from a and b. If we do want to change x and y, we need to pass in the address of x and the address of y. Then, we can update the values at those memory locations. Here is our revised swap function:</description></item><item><title>sizeof</title><link>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_6-sizeof/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_6-sizeof/index.html</guid><description>The sizeof function in C returns the number of bytes needed to store a specified type. It is needed for dynamic memory allocation because we need to know how many bytes we want to allocate.
Here is the prototype:
int sizeof(type); where type is a defined type in C, like char or int. Here are a few examples:
sizeof(int) //evaluates to 4 sizeof(char) //evaluates to 1 sizeof(double) //evaluates to 8 sizeof(int*) //evaluates to 4 sizeof(char*) //evaluates to 4</description></item><item><title>Dynamic Memory</title><link>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_7-dynamicmemory/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_7-dynamicmemory/index.html</guid><description>Currently, we can only declare arrays to be of a constant size (like 10). This is not always convenient – sometimes we want to make the size based on some user input. If we want to allocate a dynamic amount of space, we need to use C’s dynamic memory functions. Each of these functions is in &lt;stdlib.h>.
malloc This function allocates a contiguous block of memory with the specifies size (number of bytes). It returns a void pointer to the block of memory. (This pointer will be automatically cast to the correct type when you store it.)</description></item><item><title>Multi-dimensional Dynamic Arrays</title><link>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_8-multidimdynarrays/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_8-multidimdynarrays/index.html</guid><description>We can also create multi-dimensional dynamic arrays using malloc. This section will focus on creating two-dimensional arrays. You can get more dimensions by adapting the following process:
Use malloc to create an array of pointers. Each pointer in the array will point to a row in the two-dimensional array. For example:
//Final array will have 3 rows int **matrix = malloc(3*sizeof(int*)); Use malloc to allocate space for each row: int i; for (i = 0; i &lt; 3; i++) { //Final array will have 4 columns matrix [i] = malloc(4*sizeof(int)); } Now we can treat the pointer like a traditional two-dimensional array. For example, we could set every element to 0: int j; for (i = 0; i &lt; 3; i++) { for (j = 0; j &lt; 4; j++) { matrix [i][j] = 0; } } When we are done using a multi-dimensional array, we release the memory in reverse order of how we allocated it. So, first we release each row: for (i = 0; i &lt; 3; i++) { free(matrix [i]); } And then we release the top-level array of pointers:</description></item><item><title>Returning Pointers from Functions</title><link>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_9-returningptrsfromfns/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/3-chapter/3_9-returningptrsfromfns/index.html</guid><description>We can also return pointers from functions via pointer arguments rather than as the formal return value. To explain this, let’s first step back and consider the case of returning a simple type, such as int, from a function via a pointer argument.
If we write the function:
void f(int *ip) { *ip = 5; } And then call it like this:
int i; f(&amp;i); then f will “return” the value 5 by writing it to the location specified by the pointer passed by the caller; in this case, to the caller’s variable i. A function might “return” values in this way if it had multiple things to return, since a function can only have one formal return value (that is, it can only return one value via the return statement.) The important thing to notice is that for the function to return a value of type int, it used a parameter of type pointer-to-int.</description></item></channel></rss>