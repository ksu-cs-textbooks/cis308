<?xml version="1.0" encoding="utf-8" standalone="yes"?>




	
	
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pointers and Dynamic Memory on CIS 308 Textbook</title>
    <link>https://ksu-cs-textbooks.github.io/cis308/3-chapter/</link>
    <description>Recent content in Pointers and Dynamic Memory on CIS 308 Textbook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 24 Aug 2018 10:53:05 -0500</lastBuildDate><atom:link href="https://ksu-cs-textbooks.github.io/cis308/3-chapter/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Pointers</title>
      <link>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_1-pointers/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_1-pointers/</guid>
      <description>Pointers in C are variables that store the memory address of some other variable or data. They have an associated type of what kind of value they reference.
Pointers are one of the most difficult concepts in the C language. However, mastering pointers allows you do have a deeper understanding of what actually happens when your program runs. Higher-level languages do not explicitly use pointers, but they do use pointers &amp;ldquo;behind the scenes&amp;rdquo;.</description>
    </item>
    <item>
      <title>Pointers vs. Arrays</title>
      <link>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_2-pointersvsarrays/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_2-pointersvsarrays/</guid>
      <description>Arrays and pointers have a lot in common. When we do:
int nums[10]; Then we get a spot in memory that looks like this:
But what is nums? It is actually a constant pointer to the first spot in the array, nums[0]. So really, the picture looks like this:
So, &amp;amp;nums[0] (the address of the first element in the array) is the same thing as nums.
Pointer Notation Because pointers and arrays are essentially the same thing (except array addresses cannot be changed), we can also access elements in an array by treating it as a pointer.</description>
    </item>
    <item>
      <title>Iteration with Pointers</title>
      <link>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_3-interationwithpointers/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_3-interationwithpointers/</guid>
      <description>This is how we have initialized array elements in the past:
int i; int nums[10]; for (i = 0; i &amp;lt; 10; i++) { nums[i] = 0; } However, now that we can treat arrays like pointers, there is a different way to initialize array elements:
int *ip; int nums[10]; for (ip = nums; ip &amp;lt; nums+10; ip++) { *ip = 0; } Here, ip is a pointer that starts by pointing to the first element in the array.</description>
    </item>
    <item>
      <title>Pointers to Pointers</title>
      <link>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_4-pointerstopointers/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_4-pointerstopointers/</guid>
      <description>Just like a variable can be a pointer, we can also declare pointers to pointers. (We can take it even further than that, but it starts to get pretty confusing!) You can denote the &amp;ldquo;level&amp;rdquo; of the pointer by how many *’s you use in the declaration.
Here&amp;rsquo;s an example of using pointers to pointers:
int i; //declares the int i int *ip; //declares the int pointer ip int **ipp; //declares a pointer to a pointer to an int, ipp i = 36; //gives i the value 36 ip = &amp;amp;i; //now ip points to i *ip = 72; //dereferences ip to get i, and sets it to 72 (now i=72) ipp = &amp;amp;ip; //ipp points to ip, which points to i **ipp = 24; //dereferences ipp to get ip, then dereferences again to get i, //and sets it to 24 (now i = 24) </description>
    </item>
    <item>
      <title>Call by Reference</title>
      <link>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_5-callbyreference/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_5-callbyreference/</guid>
      <description>C functions are naturally call-by-value, which means that we don’t pass variables themselves – we pass their value. So, if we modify one of the parameters in our function, it does not modify the original variable passed to the function. Consider the following example:
//This example doesn’t work! void swap(int a, int b) { int temp = a; a = b; b = temp; } //assume the test code below is in another function int x = 3; int y = 4; swap(x, y); This code fragment is supposed to swap the values in x and y, so that x == 4 and y == 3.</description>
    </item>
    <item>
      <title>sizeof</title>
      <link>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_6-sizeof/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_6-sizeof/</guid>
      <description>The sizeof function in C returns the number of bytes needed to store a specified type. It is needed for dynamic memory allocation because we need to know how many bytes we want to allocate.
Here is the prototype:
int sizeof(type); where type is a defined type in C, like char or int. Here are a few examples:
sizeof(int) //evaluates to 4 sizeof(char) //evaluates to 1 sizeof(double) //evaluates to 8 sizeof(int*) //evaluates to 4 sizeof(char*) //evaluates to 4 </description>
    </item>
    <item>
      <title>Dynamic Memory</title>
      <link>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_7-dynamicmemory/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_7-dynamicmemory/</guid>
      <description>Currently, we can only declare arrays to be of a constant size (like 10). This is not always convenient – sometimes we want to make the size based on some user input. If we want to allocate a dynamic amount of space, we need to use C&amp;rsquo;s dynamic memory functions. Each of these functions is in &amp;lt;stdlib.h&amp;gt;.
malloc This function allocates a contiguous block of memory with the specifies size (number of bytes).</description>
    </item>
    <item>
      <title>Multi-dimensional Dynamic Arrays</title>
      <link>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_8-multidimdynarrays/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_8-multidimdynarrays/</guid>
      <description>We can also create multi-dimensional dynamic arrays using malloc. This section will focus on creating two-dimensional arrays. You can get more dimensions by adapting the following process:
Use malloc to create an array of pointers. Each pointer in the array will point to a row in the two-dimensional array. For example:
//Final array will have 3 rows int **matrix = malloc(3*sizeof(int*)); Use malloc to allocate space for each row: int i; for (i = 0; i &amp;lt; 3; i++) { //Final array will have 4 columns matrix [i] = malloc(4*sizeof(int)); } Now we can treat the pointer like a traditional two-dimensional array.</description>
    </item>
    <item>
      <title>Returning Pointers from Functions</title>
      <link>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_9-returningptrsfromfns/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis308/3-chapter/3_9-returningptrsfromfns/</guid>
      <description>We can also return pointers from functions via pointer arguments rather than as the formal return value. To explain this, let&amp;rsquo;s first step back and consider the case of returning a simple type, such as int, from a function via a pointer argument.
If we write the function:
void f(int *ip) { *ip = 5; } And then call it like this:
int i; f(&amp;amp;i); then f will &amp;ldquo;return&amp;rdquo; the value 5 by writing it to the location specified by the pointer passed by the caller; in this case, to the caller&amp;rsquo;s variable i.</description>
    </item>
  </channel>
</rss>