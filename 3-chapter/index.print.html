<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary"><meta name=twitter:title content="Pointers and Dynamic Memory :: CIS 308 Textbook"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis308/3-chapter/"><meta property="og:site_name" content="CIS 308 Textbook"><meta property="og:title" content="Pointers and Dynamic Memory :: CIS 308 Textbook"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Pointers and Dynamic Memory :: CIS 308 Textbook"><meta itemprop=datePublished content="2018-08-24T10:53:05-05:00"><meta itemprop=dateModified content="2023-08-10T15:07:40-05:00"><title>Pointers and Dynamic Memory :: CIS 308 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis308/3-chapter/ rel=canonical type=text/html title="Pointers and Dynamic Memory :: CIS 308 Textbook"><link href=/cis308/3-chapter/index.xml rel=alternate type=application/rss+xml title="Pointers and Dynamic Memory :: CIS 308 Textbook"><link href=/cis308/3-chapter/tele.html rel=alternate type=text/html title="Pointers and Dynamic Memory :: CIS 308 Textbook"><link href=/cis308/3-chapter/embed.html rel=alternate type=text/html title="Pointers and Dynamic Memory :: CIS 308 Textbook"><link href=/cis308/css/fontawesome-all.min.css?1755548969 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis308/css/fontawesome-all.min.css?1755548969 rel=stylesheet></noscript><link href=/cis308/css/nucleus.css?1755548969 rel=stylesheet><link href=/cis308/css/auto-complete.css?1755548969 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis308/css/auto-complete.css?1755548969 rel=stylesheet></noscript><link href=/cis308/css/perfect-scrollbar.min.css?1755548969 rel=stylesheet><link href=/cis308/css/fonts.css?1755548969 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis308/css/fonts.css?1755548969 rel=stylesheet></noscript><link href=/cis308/css/theme.css?1755548969 rel=stylesheet><link href=/cis308/css/theme-auto.css?1755548969 rel=stylesheet id=R-variant-style><link href=/cis308/css/chroma-auto.css?1755548969 rel=stylesheet id=R-variant-chroma-style><link href=/cis308/css/variant.css?1755548969 rel=stylesheet><link href=/cis308/css/print.css?1755548969 rel=stylesheet media=print><link href=/cis308/css/format-print.css?1755548969 rel=stylesheet><script src=/cis308/js/variant.js?1755548969></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis308",window.index_js_url="/cis308/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis308/css/custom.css?1755548969 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis308/3-chapter/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Pointers and Dynamic Memory</span><meta itemprop=position content="1"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis308/2-chapter/2_3-files/ title="Files (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis308/3-chapter/3_1-pointers/ title="Pointers (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><article class=chapter><header class=headline></header><div class=article-subheading>Chapter 3</div><h1 id=pointers-and-dynamic-memory>Pointers and Dynamic Memory</h1><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Pointers and Dynamic Memory</h1><article class=default><header class=headline></header><h1 id=pointers>Pointers</h1><p>Pointers in C are variables that store the memory address of some other variable or data. They have an associated type of what kind of value they reference.</p><p>Pointers are one of the most difficult concepts in the C language. However, mastering pointers allows you do have a deeper understanding of what actually happens when your program runs. Higher-level languages do not explicitly use pointers, but they do use pointers &ldquo;behind the scenes&rdquo;. Learning pointers in C can also help you understand what&rsquo;s going on in Java/C#/etc. programs.</p><h2 id=declaring>Declaring</h2><p>The type of a pointer variable is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>type*</span></span></code></pre></div><p>where <em>type</em> is the type of data this pointer will reference. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>intPtr</span><span class=p>;</span></span></span></code></pre></div><p><em>intPtr</em> can hold the address of an int variable. Another:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=n>charPtr</span><span class=p>;</span></span></span></code></pre></div><p><em>charPtr</em> can hold the address of a char variable.</p><p>When you are declaring pointers, the * can go any where between the type and the variable name. For example, all of the following are acceptable:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>intPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span> <span class=n>intPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span><span class=n>intPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>intPtr</span><span class=p>;</span></span></span></code></pre></div><p>Variables in C are not automatically initialized â€“ and this includes pointers. After declaring a pointer, it holds some garbage value that was left in that spot in memory.</p><h2 id=-operator-address-of>& Operator (Address-Of)</h2><p>The & operator returns the memory address of a variable. For example, if we have:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span></span></span></code></pre></div><p>And the <em>x</em> variable is stored at spot 1714 in memory (every variable is given a certain spot in memory, and these spots have an associated number), then if we do:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=o>&amp;</span><span class=n>x</span></span></span></code></pre></div><p>this will give us the 1714 spot.</p><p>The address-of operator isn&rsquo;t very useful unless we&rsquo;re using pointers. Since pointers are supposed to hold memory addresses, we can initialize them to be the address of some other variable.</p><p>So, suppose we have the following variable declarations:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span> <span class=c1>//x is given spot 1714 in memory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>xPtr</span><span class=p>;</span></span></span></code></pre></div><p>We can make the <em>xPtr</em> variable reference <em>x</em>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>xPtr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>;</span> <span class=c1>//Now xPtr &#34;points to&#34; x â€“ it holds address 1714
</span></span></span></code></pre></div><p>Notice that when we DECLARE a pointer, we include the *. However, when we INITIALIZE the pointer, we don&rsquo;t include the *.</p><h2 id=-operator-dereferencing>* Operator (Dereferencing)</h2><p>The * operator is an operator specifically for pointer variables. It returns the value of what is being pointed at.</p><p>For example, if we have:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span> <span class=c1>//x is given spot 1714 in memory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>xPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>xPtr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>;</span></span></span></code></pre></div><p>Then saying *<em>xPtr</em> gets us the value pointed to by <em>xPtr</em>. <em>xPtr</em> holds memory address 1714, so if I say *<em>xPtr</em>, then I get the value stored in spot 1714 â€“ which is a 4. I can also use this operator to modify the value at that spot in memory. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=o>*</span><span class=n>xPtr</span> <span class=o>=</span> <span class=mi>6</span><span class=p>;</span></span></span></code></pre></div><p>Now the value at spot 1714 is a 6. The <em>x</em> variable is stored in spot 1714, so now <em>x</em> has the value 6.</p><h2 id=example>Example</h2><p>The following example illustrates how pointers work:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span><span class=p>;</span>      <span class=c1>//i gets a memory location, say 3245, and has some random value
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>ip</span><span class=p>;</span>    <span class=c1>//ip has some random address
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>i</span> <span class=o>=</span> <span class=mi>36</span><span class=p>;</span>     <span class=c1>//i has the value 36
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=n>ip</span> <span class=o>=</span> <span class=mi>72</span><span class=p>;</span>   <span class=c1>//Most likely, causes a segmentation fault
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ip</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>;</span>    <span class=c1>//ip references memory address 3245
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=n>ip</span> <span class=o>=</span> <span class=mi>72</span><span class=p>;</span>   <span class=c1>//Memory address 3245 has value 72 (so i = 72)
</span></span></span></code></pre></div><p>The reason <code>*ip = 72</code> will cause problems is that <code>*ip</code> currently holds some random memory address, since it has not been initialized. When we say <code>*ip</code>, we&rsquo;re trying to access the memory at that random spot. This is most likely not the program&rsquo;s memory, so we will get a segmentation fault when we try to change it. (The other possibility is that we could end up overwriting one of the other program variables.)</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pointers-vs-arrays>Pointers vs. Arrays</h1><p>Arrays and pointers have a lot in common. When we do:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>nums</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span></span></span></code></pre></div><p>Then we get a spot in memory that looks like this:</p><p><a href=#R-image-487988067c16d7eeddd01af30a087bb3 class=lightbox-link><img alt="new array" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis308/images/emptyArray.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-487988067c16d7eeddd01af30a087bb3><img alt="new array" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis308/images/emptyArray.png></a></p><p>But what is <em>nums</em>? It is actually a constant pointer to the first spot in the array, <code>nums[0]</code>. So really, the picture looks like this:</p><p><a href=#R-image-35268a3367d232f8b35fc37e3a33eb0c class=lightbox-link><img alt="nums array" class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis308/images/numsArray.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-35268a3367d232f8b35fc37e3a33eb0c><img alt="nums array" class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis308/images/numsArray.png></a></p><p>So, <code>&amp;nums[0]</code> (the address of the first element in the array) is the same thing as <code>nums</code>.</p><h2 id=pointer-notation>Pointer Notation</h2><p>Because pointers and arrays are essentially the same thing (except array addresses cannot be
changed), we can also access elements in an array by treating it as a pointer. In the above
example, <code>nums</code> is a pointer to the first spot in the array. Space for arrays is reserved
contiguously, so the second element in the array is physically next to the first element. This
means that I can say:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>nums+1</span></span></code></pre></div><p>to get the memory address of the second element in the array.</p><p>Note: an integer uses 4 bytes of space. However, you donâ€™t say <code>nums+4</code> to move to the next
integer. This is because pointers have a particular type associated with them â€“ like an int â€“ and
the compiler will automatically move over the space of an int when you say <code>+1</code>.</p><p>Suppose now that you want to initialize the value at index 4 in the <code>nums</code> array to 7. You could
say:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>nums</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=mi>7</span><span class=p>;</span></span></span></code></pre></div><p>However, you could do the same thing by treating <em>nums</em> as a pointer. You can get the address of
the array element at index 4 by saying:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>nums</span><span class=o>+</span><span class=mi>4</span></span></span></code></pre></div><p>This is a pointer, so if we want to change the contents of that location to 7, we need to
dereference it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=o>*</span><span class=p>(</span><span class=n>nums</span><span class=o>+</span><span class=mi>4</span><span class=p>)</span> <span class=o>=</span> <span class=mi>7</span><span class=p>;</span></span></span></code></pre></div><h2 id=example>Example</h2><p>Recall that an array is a constant pointer to a block of reserved memory. This means that we can
change the values stored in the array, but we canâ€™t change the array itself (make it reference
another piece of memory). Consider the following statements â€“ which are legal?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span> 		<span class=c1>//OK â€“ a points to a block of 10 ints in memory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>a</span><span class=o>++</span><span class=p>;</span> 			<span class=c1>//NO â€“ The address of an array canâ€™t change
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>xp</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>	<span class=c1>//OK â€“ Now xp also points to the beginning of the array
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>a</span> <span class=o>=</span> <span class=n>xp</span><span class=p>;</span> 		<span class=c1>//NO â€“ The address of an array canâ€™t change
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>b</span><span class=p>[</span><span class=mi>5</span><span class=p>];</span> 		<span class=c1>//OK â€“ b points to a block of 5 ints in memory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>bp</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>	<span class=c1>//OK â€“ Now b also points to the beginning of the array
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>xp</span><span class=o>++</span><span class=p>;</span> 			<span class=c1>//OK â€“ Now xp points to the second element in the array
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=n>xp</span> <span class=o>=</span> <span class=mi>14</span><span class=p>;</span> 		<span class=c1>//OK â€“ The second element in the array is set to 14 (a[1] = 14)
</span></span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=iteration-with-pointers>Iteration with Pointers</h1><p>This is how we have initialized array elements in the past:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>nums</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>However, now that we can treat arrays like pointers, there is a different way to initialize array
elements:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>ip</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>nums</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>ip</span> <span class=o>=</span> <span class=n>nums</span><span class=p>;</span> <span class=n>ip</span> <span class=o>&lt;</span> <span class=n>nums</span><span class=o>+</span><span class=mi>10</span><span class=p>;</span> <span class=n>ip</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=o>*</span><span class=n>ip</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Here, <code>ip</code> is a pointer that starts by pointing to the first element in the array. We loop while the
value of <code>ip</code> (the memory address) is less than <code>nums+10</code> â€“ which is the address of the last
element in the array. Each time, <code>ip++</code> advances <code>ip</code> to point at the next element in the array.
Inside the loop, we dereference <code>ip</code> to get the current array element, and set that element to 0.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pointers-to-pointers>Pointers to Pointers</h1><p>Just like a variable can be a pointer, we can also declare pointers to pointers. (We can take it
even further than that, but it starts to get pretty confusing!) You can denote the &ldquo;level&rdquo; of the
pointer by how many *â€™s you use in the declaration.</p><p>Here&rsquo;s an example of using pointers to pointers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span><span class=p>;</span> 		<span class=c1>//declares the int i
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span><span class=n>ip</span><span class=p>;</span> 	<span class=c1>//declares the int pointer ip
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>**</span><span class=n>ipp</span><span class=p>;</span> 	<span class=c1>//declares a pointer to a pointer to an int, ipp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>i</span> <span class=o>=</span> <span class=mi>36</span><span class=p>;</span> 	<span class=c1>//gives i the value 36
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ip</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>;</span> 	<span class=c1>//now ip points to i
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>*</span><span class=n>ip</span> <span class=o>=</span> <span class=mi>72</span><span class=p>;</span> 	<span class=c1>//dereferences ip to get i, and sets it to 72 (now i=72)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ipp</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>ip</span><span class=p>;</span> 	<span class=c1>//ipp points to ip, which points to i
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>**</span><span class=n>ipp</span> <span class=o>=</span> <span class=mi>24</span><span class=p>;</span> <span class=c1>//dereferences ipp to get ip, then dereferences again to get i,
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=c1>//and sets it to 24 (now i = 24)
</span></span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=call-by-reference>Call by Reference</h1><p>C functions are naturally call-by-value, which means that we donâ€™t pass variables themselves â€“
we pass their value. So, if we modify one of the parameters in our function, it does not modify
the original variable passed to the function. Consider the following example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//This example doesnâ€™t work!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>b</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//assume the test code below is in another function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>swap</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span></span></span></code></pre></div><p>This code fragment is supposed to swap the values in <code>x</code> and <code>y</code>, so that <code>x == 4</code> and <code>y == 3</code>.
However, when we call <code>swap</code>, only the VALUES 3 and 4 are passed â€“ not <code>x</code> and <code>y</code> themselves.
The values 3 and 4 get bound to the function parameters <code>a</code> and <code>b</code>. By the end of the function, we
do have that <code>a == 4</code> and <code>b == 3</code>. However, <code>x</code> and <code>y</code> donâ€™t change because they are completely
different from <code>a</code> and <code>b</code>.
If we do want to change <code>x</code> and <code>y</code>, we need to pass in the address of <code>x</code> and the address of <code>y</code>. Then,
we can update the values at those memory locations. Here is our revised <code>swap</code> function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//Take two memory addresses (pointers)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>swap</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=o>*</span><span class=n>a</span><span class=p>;</span> 	<span class=c1>//Store the value pointed to by a
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>*</span><span class=n>a</span> <span class=o>=</span> <span class=o>*</span><span class=n>b</span><span class=p>;</span> 		<span class=c1>//Update the contents of a to be the contents of b
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span> 		<span class=c1>//Update the contents of a to be temp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><p>Now, when we call <code>swap</code>, we will need to pass the memory address of the variables we want to
swap. This means we need to use the & operator:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>swap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>x</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>y</span><span class=p>);</span></span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=sizeof>sizeof</h1><p>The <code>sizeof</code> function in C returns the number of bytes needed to store a specified type. It is
needed for dynamic memory allocation because we need to know how many bytes we want to
allocate.</p><p>Here is the prototype:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sizeof</span><span class=p>(</span><span class=n>type</span><span class=p>);</span></span></span></code></pre></div><p>where <code>type</code> is a defined type in C, like <code>char</code> or <code>int</code>. Here are a few examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> 	<span class=c1>//evaluates to 4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=p>)</span> 	<span class=c1>//evaluates to 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>sizeof</span><span class=p>(</span><span class=kt>double</span><span class=p>)</span> 	<span class=c1>//evaluates to 8
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>)</span> 	<span class=c1>//evaluates to 4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>sizeof</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span> 	<span class=c1>//evaluates to 4
</span></span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=dynamic-memory>Dynamic Memory</h1><p>Currently, we can only declare arrays to be of a constant size (like 10). This is not always
convenient â€“ sometimes we want to make the size based on some user input. If we want to
allocate a dynamic amount of space, we need to use C&rsquo;s dynamic memory functions. Each of
these functions is in <code>&lt;stdlib.h></code>.</p><h2 id=malloc>malloc</h2><p>This function allocates a contiguous block of memory with the specifies size (number of bytes).
It returns a void pointer to the block of memory. (This pointer will be automatically cast to the
correct type when you store it.)</p><p>Here is the prototype:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>malloc</span><span class=p>(</span><span class=kt>int</span> <span class=n>numBytes</span><span class=p>);</span></span></span></code></pre></div><p>For example, we could allocate an array like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>nums1</span><span class=p>[</span><span class=mi>5</span><span class=p>];</span></span></span></code></pre></div><p>Or we could do the same thing using <code>malloc</code>. If we use <code>malloc</code>, we need to specify the
number of bytes to reserve. We want 5 ints, and each int takes up <code>sizeof(int)</code> bytes. So,
the total needed is <code>5*sizeof(int)</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//The result of malloc is automatically cast to an int*
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span><span class=o>*</span> <span class=n>nums2</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>5</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span></span></span></code></pre></div><p>Now, we can treat <code>nums2</code> just like an array. For instance, if we wanted to initialize all elements
in <code>nums2</code> to 0:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>nums2</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> 	<span class=c1>//The compiler converts this to *(nums2+i) = 0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><p>Allocating arrays with malloc has several key difference from standard array allocation:</p><ul><li><code>malloc</code> can handle a variable for the desired size; a standard array cannot</li><li>The result of <code>malloc</code> is a pointer; the result of a standard array allocation is a constant pointer</li><li><code>malloc</code> memory is allocated on the heap. If there is not enough space to do the allocation, <code>malloc</code> will return NULL. An array is allocated on the program stack â€“ if there is not enough space, the program simply won&rsquo;t compile.</li></ul><h2 id=calloc>calloc</h2><p>The <code>calloc</code> function is very similar to <code>malloc</code>. The only difference is that when arrays are
allocated using <code>calloc</code>, all elements are automatically initialized to 0.</p><p>Here is the prototype:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>calloc</span><span class=p>(</span><span class=kt>int</span> <span class=n>numElems</span><span class=p>,</span> <span class=kt>int</span> <span class=n>sizePerElem</span><span class=p>);</span></span></span></code></pre></div><p>The prototype of <code>calloc</code> is also a little different than the one for <code>malloc</code>. It takes two
arguments â€“ the number of elements you want in the array, and the number of bytes needed for
each elements. Like <code>malloc</code>, <code>calloc</code> returns a void pointer to the contiguous block of
memory it allocated. This pointer will be automatically cast to the appropriate type when you
store it.</p><p>Here&rsquo;s how to create an array of 10 ints, all initialized to 0:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>nums</span> <span class=o>=</span> <span class=nf>calloc</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span></span></span></code></pre></div><p>Now you can use <code>nums</code> just like an array. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>nums</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span></span></span></code></pre></div><p>Like <code>malloc</code>, <code>calloc</code> will return NULL if there is not enough space to do the allocation. In
both cases, it&rsquo;s a good idea to check if the pointer is NULL before you use it.</p><p>For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>nums</span> <span class=o>=</span> <span class=nf>calloc</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>nums</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Not enough space.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//Use nums as usual
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><h2 id=realloc>realloc</h2><p>The <code>realloc</code> function allows you to easily expand and shrink the space allocated for an array.</p><p>Here is the prototype:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span><span class=o>*</span> <span class=nf>realloc</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>origPtr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>newSize</span><span class=p>);</span></span></span></code></pre></div><p>This function takes your original pointer and the desired new size in bytes. It looks for a
contiguous block of memory with the desired size. If it can find one, it copies the contents of the
old array into the new block of memory. Then it releases the space needed for the old array, and
returns a void pointer to the new block of memory.</p><p>The <code>realloc</code> function doesn&rsquo;t always behave as you intend. Here are the possible return
values of <code>realloc</code>:</p><ul><li>NULL (if not enough space is found)</li><li>The original pointer (if there is enough space at that location)</li><li>A new pointer to a different spot in memory</li></ul><p>Suppose we allocate the <code>nums</code> array like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>nums</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>10</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span></span></span></code></pre></div><p>Now we decide that we want <code>nums</code> to hold 15 elements instead of 10. Here&rsquo;s what we might
try:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>nums</span> <span class=o>=</span> <span class=nf>realloc</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=mi>15</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span></span></span></code></pre></div><p>Suppose that <code>realloc</code> could not find enough space to grant the request â€“ so it returns NULL.
This means that we assign NULL to our original <code>nums</code> pointer. Now <code>nums</code> does not reference
the original array â€“ in fact, nothing does. The original array is stuck in memory with no way to
get at it â€“ this is called a <em>memory leak</em>.</p><p>To fix this problem, assign a temporary pointer to the result of <code>realloc</code>. Then, if it&rsquo;s not
NULL, reassign the original pointer. This keeps you from losing your array:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>temp</span> <span class=o>=</span> <span class=nf>realloc</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=mi>15</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>temp</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>nums</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><h2 id=free>free</h2><p>In Java and C#, any memory that you&rsquo;re no longer using will be cleaned up by the garbage collector. C
has no garbage collector, so you are in charge of releasing memory that you&rsquo;re done with. If you
never release any allocated memory, you will eventually run out of space.</p><p>The C function that releases dynamic memory is called <code>free</code>. Here is the prototype:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>free</span><span class=p>(</span><span class=kt>void</span><span class=o>*</span> <span class=n>pointer</span><span class=p>);</span></span></span></code></pre></div><p>Note that even though <code>free</code> takes a void pointer, it can take any type of pointer that has been
dynamically allocated.</p><p>Here&rsquo;s an example of using <code>free</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>nums</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>10</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//done using nums
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>free</span><span class=p>(</span><span class=n>nums</span><span class=p>);</span></span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=multi-dimensional-dynamic-arrays>Multi-dimensional Dynamic Arrays</h1><p>We can also create multi-dimensional dynamic arrays using <code>malloc</code>. This section will focus on
creating two-dimensional arrays. You can get more dimensions by adapting the following
process:</p><ol><li>Use <code>malloc</code> to create an array of pointers. Each pointer in the array will point to a row
in the two-dimensional array.</li></ol><p>For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//Final array will have 3 rows
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>**</span><span class=n>matrix</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>3</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span><span class=p>));</span></span></span></code></pre></div><ol start=2><li>Use <code>malloc</code> to allocate space for each row:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//Final array will have 4 columns
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>matrix</span> <span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=mi>4</span><span class=o>*</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><ol start=3><li>Now we can treat the pointer like a traditional two-dimensional array. For example, we
could set every element to 0:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=mi>4</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>matrix</span> <span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><ol start=4><li>When we are done using a multi-dimensional array, we release the memory in reverse order of
how we allocated it. So, first we release each row:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>free</span><span class=p>(</span><span class=n>matrix</span> <span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>And then we release the top-level array of pointers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>free</span><span class=p>(</span><span class=n>matrix</span><span class=p>);</span></span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=returning-pointers-from-functions>Returning Pointers from Functions</h1><p>We can also return pointers from functions via
pointer arguments rather than as the formal return value. To explain this, let&rsquo;s first step back and
consider the case of returning a simple type, such as int, from a function via a pointer argument.</p><p>If we write the function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>f</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>ip</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>ip</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>And then call it like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>f</span><span class=p>(</span><span class=o>&amp;</span><span class=n>i</span><span class=p>);</span></span></span></code></pre></div><p>then <code>f</code> will &ldquo;return&rdquo; the value 5 by writing it to the location specified by the pointer passed by the
caller; in this case, to the caller&rsquo;s variable <code>i</code>. A function might &ldquo;return&rdquo; values in this way if it had
multiple things to return, since a function can only have one formal return value (that is, it can only
return one value via the return statement.) The important thing to notice is that for the function to
return a value of type int, it used a parameter of type pointer-to-int.</p><p>Now, suppose that a function wants to return a pointer in this way. The corresponding parameter will
then have to be a pointer to a pointer. For example, here is a function which tries to allocate
memory for a string of length <code>n</code>, and which returns zero (<code>false</code>) if it fails and 1 (nonzero, or <code>true</code>)
if it succeeds, returning the actual pointer to the allocated memory via a pointer:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>allocstr</span><span class=p>(</span><span class=kt>int</span> <span class=n>len</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>retptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=c1>//+1 for the \0 character
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>char</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>len</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>p</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>retptr</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>The caller can then do something like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>string</span> <span class=o>=</span> <span class=s>&#34;Hello, world!&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=o>*</span><span class=n>copystr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=nf>allocstr</span><span class=p>(</span><span class=nf>strlen</span><span class=p>(</span><span class=n>string</span><span class=p>),</span> <span class=o>&amp;</span><span class=n>copystr</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>strcpy</span><span class=p>(</span><span class=n>copystr</span><span class=p>,</span> <span class=n>string</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;out of memory</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis308/commit/67149f1b1c3dfffeaf11fa09cef14508de147aac>Aug 10, 2023</a></p></div></div><script src=/cis308/js/clipboard.min.js?1755548969 defer></script><script src=/cis308/js/perfect-scrollbar.min.js?1755548969 defer></script><script src=/cis308/js/theme.js?1755548969 defer></script></body></html>