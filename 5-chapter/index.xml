<?xml version="1.0" encoding="utf-8" standalone="yes"?>




	
	
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			

	
	
			
			
			

	
	
			

	
	
			
			

	
	
			
			

	
	
			
			

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Multiple Files on CIS 308 Textbook</title>
    <link>https://ksu-cs-textbooks.github.io/cis308/5-chapter/</link>
    <description>Recent content in Multiple Files on CIS 308 Textbook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 24 Aug 2018 10:53:05 -0500</lastBuildDate><atom:link href="https://ksu-cs-textbooks.github.io/cis308/5-chapter/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Header Files</title>
      <link>https://ksu-cs-textbooks.github.io/cis308/5-chapter/5_1-headerfiles/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis308/5-chapter/5_1-headerfiles/</guid>
      <description>Our first step in writing a program with multiple files is to just divide related functions into different .c files. However, suppose we&amp;rsquo;re in our main function and we call a function from a different file? This is just like calling a C library function without using any include statements. The compiler will not know where to find the outside function.
To solve this within the C libraries, function prototypes are placed in header files (.</description>
    </item>
    <item>
      <title>Makefiles</title>
      <link>https://ksu-cs-textbooks.github.io/cis308/5-chapter/5_2-makefiles/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis308/5-chapter/5_2-makefiles/</guid>
      <description>It now takes three lines to compile our program, which is a pain to have to type every time we make a change. We can simplify compilation by placing all of the compilation instructions in a single file called a Makefile (with NO extension).
Here is the format of a Makefile: compiler declaration compiler flags declaration executable name declaration header list declaration object list declaration compiling/linking instruction cleaning instruction (removing output files) (There are many other options for creating Makefiles, but we will use the template above in this class.</description>
    </item>
    <item>
      <title>Extern Variables</title>
      <link>https://ksu-cs-textbooks.github.io/cis308/5-chapter/5_3-externvariables/</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis308/5-chapter/5_3-externvariables/</guid>
      <description>Sometimes when our program is in multiple files, we still want to define variables that are visible to each file. Here&amp;rsquo;s how to do this:
Declare the global variable in a .h file. This can either be done in a .h file with some of your function prototypes, or in a special file, globals.h, that contains the declarations of all global variables. If you do use a special globals header file, it does not need a corresponding .</description>
    </item>
  </channel>
</rss>