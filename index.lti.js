var relearn_lti_index=[{breadcrumb:"",description:"",modified:"2023-08-10T15:07:40-05:00",tags:[],title:"Getting Started",uri:"/cis308/0-chapter/index.html"},{breadcrumb:"",description:"",modified:"2023-08-10T15:07:40-05:00",tags:[],title:"C Basics",uri:"/cis308/1-chapter/index.html"},{breadcrumb:"",description:"",modified:"2023-08-10T15:07:40-05:00",tags:[],title:"Arrays, Strings, and Files",uri:"/cis308/2-chapter/index.html"},{breadcrumb:"",description:"",modified:"2023-08-10T15:07:40-05:00",tags:[],title:"Pointers and Dynamic Memory",uri:"/cis308/3-chapter/index.html"},{breadcrumb:"",description:"",modified:"2023-08-10T15:07:40-05:00",tags:[],title:"Structs",uri:"/cis308/4-chapter/index.html"},{breadcrumb:"",description:`Up to this point, all of our programs have been written within a single file. There is nothing wrong with this – a C program is just a bunch of functions, and it’s fine to group those functions within a single file. However, as your programs get bigger, it’s nice to physically separate functions into different files. This makes it easier to find certain pieces of your program.
Separating functions also promotes reuse. Right now, if we wanted to reuse a function we’d written in another program, we would have to copy it from our old program to our new one. With multiple files, we can separate the functions we want reused and just link to that file when we want to use them (this is like separating the C library functions and including them when we want to use them).`,modified:"2023-08-10T15:07:40-05:00",tags:[],title:"Multiple Files",uri:"/cis308/5-chapter/index.html"},{breadcrumb:"",description:"",modified:"2023-08-10T15:07:40-05:00",tags:[],title:"User-Defined Types",uri:"/cis308/6-chapter/index.html"},{breadcrumb:"",description:"The	pointers we	have looked	at	so	far	have	all	been	pointers	to	various	types	of	data	objects, (such	as	int,	char,	double,	struct	person,	and	pointer-to-int),	but	it	is	also	possible	to	have pointers	to	functions.	Pointers	to	functions	are	useful	for	approximately	the	same	reasons	as pointers	to	data:	when	you	want	an	extra	level	of	indirection, or	when	you’d	like	the	same	piece	of code	to	call	different	functions	depending	on	circumstances.",modified:"2023-08-10T15:07:40-05:00",tags:[],title:"Pointers to Functions",uri:"/cis308/7-chapter/index.html"},{breadcrumb:"Getting Started",description:"VS Code In CIS 308, we will edit our C programs using VS Code with C/C++ extensions. You likely already have Visual Studio (2019 or 2022) installed on your computer from CIS 300 and/or 400 – however, we will not be using Visual Studio in CIS 308. While it does have a C++ compiler, it behaves differently than more widely accepted C compilers (versions of gcc and clang). Finally, this class has a secondary goal of exposing students to a variety of Unix/Linux tools – something that cannot be done as easily in Visual Studio.",modified:"2022-08-24T10:04:00-05:00",tags:[],title:"VS Code",uri:"/cis308/0-chapter/0_1-vscode/index.html"},{breadcrumb:"Getting Started",description:`This class will use GitHub links to create initial repositories for both labs and programming projects, similarly to what you have done in CIS 300 and 301.
GitHub account First, you will need to create a GitHub account here. If you already have one, you can use your existing account.
Verify a git install You will likely already have a command-line version of git installed on your machine. To check, open a folder in VS Code, display the integrated terminal, and type:`,modified:"2022-08-24T10:04:00-05:00",tags:[],title:"Using git",uri:"/cis308/0-chapter/0_2-usinggit/index.html"},{breadcrumb:"Getting Started",description:`After you have installed VS Code along with gcc, you can write C programs in the VS Code editor and then use the integrated terminal to compile and run.
Hello, World! in VS Code Here is a Hello, World! program written in C using VS Code. It is saved to the file hello.c (note that .c is the extension for C programs):`,modified:"2022-08-24T10:04:00-05:00",tags:[],title:"Compiling and Running",uri:"/cis308/0-chapter/0_3-compilerun/index.html"},{breadcrumb:"Getting Started",description:`A side goal of this class is for students to become more comfortable with using the terminal. With practice, you will find that you are faster at navigating folders, creating files/folders, compiling/running programs, using tools stuch as git, etc. using the terminal than you are using a GUI. Familiarity with a terminal is especially useful in system administration and web development.
Summary of common terminal commands Here is a summary table of the most common terminal commands for this course:`,modified:"2022-08-24T10:30:52-05:00",tags:[],title:"Terminal commands",uri:"/cis308/0-chapter/0_4-terminal/index.html"},{breadcrumb:"Getting Started",description:`gdb is the C debugger. It allows you to create an executable specifically for debugging purposes.
Getting gdb First, ensure that you have gdb installed.
gdb on Windows Type in a terminal:
gdb --version If you see a version number, then you already have gdb installed. If you see an error that gdb is unrecognized, you will need to install it. Launch a MSYS2 prompt (Windows icon->type MSYS2) and then type the following in MSYS2:`,modified:"2023-02-16T15:35:41-06:00",tags:[],title:"Debugging C programs",uri:"/cis308/0-chapter/0_5-debugging/index.html"},{breadcrumb:"Getting Started",description:"In the case that you are unable (or uninterested) to install some of the C tools on your own machine (such as gcc, gdb, or make), you can install the Remote - SSH extension in VS Code. This will allow you to remotely connect to the CS Linux server, which already has all the C tools installed. You will be able to use VS Code to edit files that are stored on your CS department U: drive the same way that you would edit local files.",modified:"2022-10-17T16:25:24-05:00",tags:[],title:"Remote Access",uri:"/cis308/0-chapter/0_6_remoteaccess/index.html"},{breadcrumb:"C Basics",description:`The first program students write in any new language is the “Hello, World” program. Here’s how it looks in C:
#include <stdio.h> int main() { printf("Hello, World!\\n"); return 0; } To write and run this program see the Tools Guide in section 0.1 for more information. It should print “Hello, World!” to the console.`,modified:"2022-06-15T14:34:10-05:00",tags:[],title:"Hello, World",uri:"/cis308/1-chapter/1_1-helloworld/index.html"},{breadcrumb:"C Basics",description:`Declaring Variables Variables in C are declared exactly like variables in Java or C#. Just say:
type name; where type is the type of the variable, and name is its name. The most common types in C are:
int double float char Notice that C does not have a boolean type or a string type. Some examples:
int num; char c; double val; Initializing Variables To initialize:
name = value; Where name is the name of the variable, and value is the value you want to store in it. You can also do:`,modified:"2022-08-22T12:00:25-05:00",tags:[],title:"Variables",uri:"/cis308/1-chapter/1_2-variables/index.html"},{breadcrumb:"C Basics",description:`printf Function As you’ve seen, the printf function is used to display output in C. For example, to display a string of text:
printf("Hello\\n"); Note that you always need to specify the newline character (\\n). There is no println equivalent in C.
Printing Variables Printing variables works a bit differently. First, you specify the kind of variable that’s going to be printed (called a control string). Then, outside the string, you give the corresponding variable name.`,modified:"2022-05-06T15:39:09-05:00",tags:[],title:"Printing",uri:"/cis308/1-chapter/1_3-printing/index.html"},{breadcrumb:"C Basics",description:`User input in C is, in short, a pain. There are three major input functions: getchar(), scanf(...), and fgets(...). To use any of these functions, you must include the stdio.h library.
getchar() The getchar() function takes no arguments and returns the very next character in the standard input stream. If there are no more characters in the input stream, it returns the constant EOF.
Here’s an example that reads a student’s letter grade and then prints it back to the console.`,modified:"2022-08-22T12:00:25-05:00",tags:[],title:"User Input",uri:"/cis308/1-chapter/1_4-userinput/index.html"},{breadcrumb:"C Basics",description:`C has if-statements and switch statements that work just like those in Jav and C#.
Here is a sample if-statement:
int age; //initialize age //print either Child, Teenager, or Adult, depending on age if (num < 11) { printf("Child\\n"); } else if (num < 18) { printf("Teenager\\n"); } else printf("Adult\\n"); Here is a sample switch statement. The expression in the switch clause must evaluate to either a character or an integer:
char grade; printf("Enter your grade: "); grade = getchar(); getchar(); //read and discard newline character switch (grade) { case 'A': printf("Excellent\\n"); break; case 'B': printf("Good\\n"); break; case 'C': printf("Average\\n"); break; case 'D': printf("Poor\\n"); break; case 'F': printf("Failing\\n"); break; default: printf("Invalid grade\\n"); }`,modified:"2022-04-06T15:03:22-05:00",tags:[],title:"Selection Structures",uri:"/cis308/1-chapter/1_5-selectionstructures/index.html"},{breadcrumb:"C Basics",description:`There are three kinds of loops in C – while, do-while, and for. Their syntax is exactly the same as loops in Java and C#.
While Loop The code in a while loop executes repeatedly until a specified condition becomes false. If the condition is false before the first execution of the loop, then the entire loop will be skipped.
This example will read and print every character typed by the user (up until they press enter):`,modified:"2022-08-22T12:00:25-05:00",tags:[],title:"Loops",uri:"/cis308/1-chapter/1_6-loops/index.html"},{breadcrumb:"C Basics",description:`Functions in C are very similar to methods in other languages, except functions are not associated with any class. (They are like static methods in Java and C#.) They take a number of parameters, perform on operation on those parameters, and may or may not return a value.
Function Prototypes Some C compilers will complain if they see a call to a function before they’ve seen the function itself. To avoid this problem, it’s best to include a prototype for a function at the top of the file, and then to implement it someplace else in the file.`,modified:"2022-05-06T15:39:09-05:00",tags:[],title:"Functions",uri:"/cis308/1-chapter/1_7-functions/index.html"},{breadcrumb:"C Basics",description:`All the variables we’ve seen so far have been local variables – variables that are defined within a function. These variables are only visible within that function.
Consider this function:
int count(void) { int sum = 0; sum++; return sum; } Each time we call count, the sum variable is set back to 0, and the return value is 1. sum does not retain its value across function calls.
If we did want this function to keep track of how many times it had been called, we could store sum as a global variable. Global variables are declared outside any function, and are visible to any function in the same file:`,modified:"2022-05-06T15:39:09-05:00",tags:[],title:"Global Variables",uri:"/cis308/1-chapter/1_8-globalvariables/index.html"},{breadcrumb:"Arrays, Strings, and Files",description:`Arrays in C are, for the most part, the same as arrays in Java or C#. Here are the key differences:
Arrays in C must be of a constant size (not a variable size from user input, for example) Arrays in C do not have an associated length field that keep track of the number of slots in the array (you must keep track of this information yourself) Declaring Here is the format for declaring an array:`,modified:"2022-08-03T11:47:25-05:00",tags:[],title:"Arrays",uri:"/cis308/2-chapter/2_1-arrays/index.html"},{breadcrumb:"Arrays, Strings, and Files",description:`We saw before that there is no string type in C. This is true – but you can simulate a string by using an array of characters that is terminated with a special end-of-string character, ‘\\0’.
String Variables A string literal can be declared as follows:
char str[] = "Hello"; After this line, str references the following characters in memory:
0 1 2 3 4 5 H e l l o \\0 We could have created the same string like this:`,modified:"2023-06-04T16:47:00-05:00",tags:[],title:"Strings",uri:"/cis308/2-chapter/2_2-strings/index.html"},{breadcrumb:"Arrays, Strings, and Files",description:`This section contains information on opening a file, reading from a file, and writing to a file. I only cover how to interact with text files – it is also possible to read from and write to binary files.
Whenever you are doing file I/O, you need to add:
#include <stdio.h> Opening a File Before we can interact with a file, we need to open it. The fopen function lets us open files for different kinds of input and output. Here’s the prototype:`,modified:"2023-06-04T16:42:09-05:00",tags:[],title:"Files",uri:"/cis308/2-chapter/2_3-files/index.html"},{breadcrumb:"Pointers and Dynamic Memory",description:`Pointers in C are variables that store the memory address of some other variable or data. They have an associated type of what kind of value they reference.
Pointers are one of the most difficult concepts in the C language. However, mastering pointers allows you do have a deeper understanding of what actually happens when your program runs. Higher-level languages do not explicitly use pointers, but they do use pointers “behind the scenes”. Learning pointers in C can also help you understand what’s going on in Java/C#/etc. programs.`,modified:"2022-09-14T10:32:33-05:00",tags:[],title:"Pointers",uri:"/cis308/3-chapter/3_1-pointers/index.html"},{breadcrumb:"Pointers and Dynamic Memory",description:`Arrays and pointers have a lot in common. When we do:
int nums[10]; Then we get a spot in memory that looks like this:
But what is nums? It is actually a constant pointer to the first spot in the array, nums[0]. So really, the picture looks like this:`,modified:"2022-11-30T15:23:02-06:00",tags:[],title:"Pointers vs. Arrays",uri:"/cis308/3-chapter/3_2-pointersvsarrays/index.html"},{breadcrumb:"Pointers and Dynamic Memory",description:`This is how we have initialized array elements in the past:
int i; int nums[10]; for (i = 0; i < 10; i++) { nums[i] = 0; } However, now that we can treat arrays like pointers, there is a different way to initialize array elements:
int *ip; int nums[10]; for (ip = nums; ip < nums+10; ip++) { *ip = 0; } Here, ip is a pointer that starts by pointing to the first element in the array. We loop while the value of ip (the memory address) is less than nums+10 – which is the address of the last element in the array. Each time, ip++ advances ip to point at the next element in the array. Inside the loop, we dereference ip to get the current array element, and set that element to 0.`,modified:"2022-08-03T11:47:25-05:00",tags:[],title:"Iteration with Pointers",uri:"/cis308/3-chapter/3_3-interationwithpointers/index.html"},{breadcrumb:"Pointers and Dynamic Memory",description:`Just like a variable can be a pointer, we can also declare pointers to pointers. (We can take it even further than that, but it starts to get pretty confusing!) You can denote the “level” of the pointer by how many *’s you use in the declaration.
Here’s an example of using pointers to pointers:
int i; //declares the int i int *ip; //declares the int pointer ip int **ipp; //declares a pointer to a pointer to an int, ipp i = 36; //gives i the value 36 ip = &i; //now ip points to i *ip = 72; //dereferences ip to get i, and sets it to 72 (now i=72) ipp = &ip; //ipp points to ip, which points to i **ipp = 24; //dereferences ipp to get ip, then dereferences again to get i, //and sets it to 24 (now i = 24)`,modified:"2022-04-26T14:40:35-05:00",tags:[],title:"Pointers to Pointers",uri:"/cis308/3-chapter/3_4-pointerstopointers/index.html"},{breadcrumb:"Pointers and Dynamic Memory",description:`C functions are naturally call-by-value, which means that we don’t pass variables themselves – we pass their value. So, if we modify one of the parameters in our function, it does not modify the original variable passed to the function. Consider the following example:
//This example doesn’t work! void swap(int a, int b) { int temp = a; a = b; b = temp; } //assume the test code below is in another function int x = 3; int y = 4; swap(x, y); This code fragment is supposed to swap the values in x and y, so that x == 4 and y == 3. However, when we call swap, only the VALUES 3 and 4 are passed – not x and y themselves. The values 3 and 4 get bound to the function parameters a and b. By the end of the function, we do have that a == 4 and b == 3. However, x and y don’t change because they are completely different from a and b. If we do want to change x and y, we need to pass in the address of x and the address of y. Then, we can update the values at those memory locations. Here is our revised swap function:`,modified:"2022-08-03T11:47:25-05:00",tags:[],title:"Call by Reference",uri:"/cis308/3-chapter/3_5-callbyreference/index.html"},{breadcrumb:"Pointers and Dynamic Memory",description:`The sizeof function in C returns the number of bytes needed to store a specified type. It is needed for dynamic memory allocation because we need to know how many bytes we want to allocate.
Here is the prototype:
int sizeof(type); where type is a defined type in C, like char or int. Here are a few examples:
sizeof(int) //evaluates to 4 sizeof(char) //evaluates to 1 sizeof(double) //evaluates to 8 sizeof(int*) //evaluates to 4 sizeof(char*) //evaluates to 4`,modified:"2022-08-03T11:47:25-05:00",tags:[],title:"sizeof",uri:"/cis308/3-chapter/3_6-sizeof/index.html"},{breadcrumb:"Pointers and Dynamic Memory",description:`Currently, we can only declare arrays to be of a constant size (like 10). This is not always convenient – sometimes we want to make the size based on some user input. If we want to allocate a dynamic amount of space, we need to use C’s dynamic memory functions. Each of these functions is in <stdlib.h>.
malloc This function allocates a contiguous block of memory with the specifies size (number of bytes). It returns a void pointer to the block of memory. (This pointer will be automatically cast to the correct type when you store it.)`,modified:"2022-08-03T11:47:25-05:00",tags:[],title:"Dynamic Memory",uri:"/cis308/3-chapter/3_7-dynamicmemory/index.html"},{breadcrumb:"Pointers and Dynamic Memory",description:`We can also create multi-dimensional dynamic arrays using malloc. This section will focus on creating two-dimensional arrays. You can get more dimensions by adapting the following process:
Use malloc to create an array of pointers. Each pointer in the array will point to a row in the two-dimensional array. For example:
//Final array will have 3 rows int **matrix = malloc(3*sizeof(int*)); Use malloc to allocate space for each row: int i; for (i = 0; i < 3; i++) { //Final array will have 4 columns matrix [i] = malloc(4*sizeof(int)); } Now we can treat the pointer like a traditional two-dimensional array. For example, we could set every element to 0: int j; for (i = 0; i < 3; i++) { for (j = 0; j < 4; j++) { matrix [i][j] = 0; } } When we are done using a multi-dimensional array, we release the memory in reverse order of how we allocated it. So, first we release each row: for (i = 0; i < 3; i++) { free(matrix [i]); } And then we release the top-level array of pointers:`,modified:"2022-08-03T11:47:25-05:00",tags:[],title:"Multi-dimensional Dynamic Arrays",uri:"/cis308/3-chapter/3_8-multidimdynarrays/index.html"},{breadcrumb:"Pointers and Dynamic Memory",description:`We can also return pointers from functions via pointer arguments rather than as the formal return value. To explain this, let’s first step back and consider the case of returning a simple type, such as int, from a function via a pointer argument.
If we write the function:
void f(int *ip) { *ip = 5; } And then call it like this:
int i; f(&i); then f will “return” the value 5 by writing it to the location specified by the pointer passed by the caller; in this case, to the caller’s variable i. A function might “return” values in this way if it had multiple things to return, since a function can only have one formal return value (that is, it can only return one value via the return statement.) The important thing to notice is that for the function to return a value of type int, it used a parameter of type pointer-to-int.`,modified:"2022-08-16T09:30:39-05:00",tags:[],title:"Returning Pointers from Functions",uri:"/cis308/3-chapter/3_9-returningptrsfromfns/index.html"},{breadcrumb:"Structs",description:`C is a procedural programming language, which means that a program is just a collection of functions – no classes. However, C does have a construct called a struct that is similar to a data class in Java. A struct is simply a new variable type that is a collection of related data.
Syntax Here is the format of a struct declaration:
struct name { type1 name1; type2 name2; ... } objList; Here, name is the optional name for this structure type. This name is needed if you plan to created any variables of this struct type. The type name elements are fields that you want in your struct. For example, if the struct represented a person, you might want these fields:`,modified:"2022-08-03T11:47:25-05:00",tags:[],title:"Struct Syntax",uri:"/cis308/4-chapter/4_1-structsyntax/index.html"},{breadcrumb:"Structs",description:`Structs can be declared at any point in a C program, but they are usually declared with the global variables (right after the include statements). This way, the struct type can be used throughout the file.
Here is an example that uses a struct to store a two-dimensional point (x, y location). It gets two points as input, and then prints the equation that passes through the points.
#include <stdio.h> struct point { int x; int y; }; //No variables declared here double getSlope(int, int, int, int); double getIntercept(int, int, double); int main() { struct point p1; struct point p2; double slope; double intercept; printf("Enter point1, e.g. (1, 2): "); scanf("(%d, %d)", &(p1.x), &(p1.y)); printf("Enter point2, e.g. (1, 2): "); scanf("(%d, %d)", &(p2.x), &(p2.y)); slope = getSlope(p1.x, p1.y, p2.x, p2.y); intercept = getIntercept(p1.x, p1.y, slope); //prints equation in form y = mx + b //m: slope, b: y-intercept printf("y = %.2lfx + %.2lf\\n", slope, intercept); return 0; } double getSlope(int x1, int x2, int y1, int y2) { //slope = change in y / change in x return (y2-y1)/(x2-x1); } double getIntercept(int x, int y, double slope) { //if y = mx + b, b = y - mx return y - slope*x; }`,modified:"2022-05-06T15:39:09-05:00",tags:[],title:"Struct Example",uri:"/cis308/4-chapter/4_2-structexample/index.html"},{breadcrumb:"Structs",description:`We could have also written the point example by passing the point structs to the getSlope and getIntercept functions (instead of passing their fields). This works just like passing other variable types, except struct point will be an argument type. Here’s the example when we pass the points to the functions:
#include <stdio.h> struct point { int x; int y; }; //No variables declared here double getSlope(struct point, struct point); double getIntercept(struct point, double); int main() { struct point p1; struct point p2; double slope; double intercept; printf("Enter point1, e.g. (1, 2): "); scanf("(%d, %d)", &(p1.x), &(p1.y)); printf("Enter point2, e.g. (1, 2): "); scanf("(%d, %d)", &(p2.x), &(p2.y)); slope = getSlope(p1, p2); intercept = getIntercept(p1, slope); //prints equation in form y = mx + b //m: slope, b: y-intercept printf("y = %.2lfx + %.2lf\\n", slope, intercept); return 0; } double getSlope(struct point p1, struct point p2) { //slope = change in y / change in x return (p2.y-p1.y)/(p2.x-p1.x); } double getIntercept(struct point p, double slope) { //if y = mx + b, b = y - mx return p.y - slope*p.x; }`,modified:"2024-06-27T14:09:49-05:00",tags:[],title:"Structs and Functions",uri:"/cis308/4-chapter/4_3-structsandfunctions/index.html"},{breadcrumb:"Structs",description:`You can create arrays of structs in C just like you can create arrays of any other type. The format for creating constant-sized arrays is:
type name[size]; Consider the person struct again:
struct person { char name[20]; int age; }; Here’s how to create a 3-slot array of type struct person called group:
//"struct person" is the type; "group" is the array name struct person group[3]; When you create an array of type struct, C allocates space for each struct element (and its fields) in the array.`,modified:"2022-08-03T15:29:41-05:00",tags:[],title:"Arrays of Structs",uri:"/cis308/4-chapter/4_4-arraysofstructs/index.html"},{breadcrumb:"Structs",description:`You can declare a pointer to a struct just like you declare a pointer to another element type. The format for declaring a pointer is:
type* name; So, to declare a pointer to a struct person element, we could say:
struct person* personPtr; Suppose we have another struct person variable:
struct person p1; strcpy(p1.name, "Jill"); p1.age = 18; Then we can make personPtr point to p1:
personPtr = &p1; Allocating Memory We can also create struct variables by:`,modified:"2022-08-03T11:47:25-05:00",tags:[],title:"Pointers to Structs",uri:"/cis308/4-chapter/4_5-pointerstostructs/index.html"},{breadcrumb:"Structs",description:`We can use structs to help implement all the common data structures in C. For example, whereas before we would have created a Node class to help us write a linked list, we will now create a node struct:
struct node { int data; struct node *next; //pointer to next node in list }; Suppose we want to create a linked list with a single node. First, we declare a head variable:`,modified:"2022-05-06T15:39:09-05:00",tags:[],title:"Linked Lists",uri:"/cis308/4-chapter/4_6-linkedlists/index.html"},{breadcrumb:"Structs",description:`Let’s look at how pointers to pointers can be used to eliminate a nuisance we’ve had when trying to insert and delete items in linked lists. For simplicity, we’ll consider lists of integers, built using this structure:
struct node { int data; struct node *next; }; Suppose we’re trying to write some code to delete a given integer from a list. The straightforward solution looks like this:
//delete node containing i from list pointed to by lp struct node *lp, *prevlp; for(lp = list; lp != NULL; lp = lp->next) { if(lp->item == i) { if(lp == list) list = lp->next; else { prevlp->next = lp->next; } break; } prevlp = lp; } This code works, but it has two flaws. One is that it must use an extra variable to keep track of the node behind the one it’s looking at, and the other is that it must use an extra test to special-case the situation in which the node being deleted is at the head of the list. Both problems arise because the deletion of a node from the list involves modifying the previous pointer to point to the next node (that is, the node before the deleted node to point to the one following). But, depending on whether the node being deleted is the first node in the list or not, the pointer that needs modifying is either the pointer that points to the head of the list, or the next pointer in the previous node.`,modified:"2023-02-27T17:01:33-06:00",tags:[],title:"Pointers to Pointers in Linked Lists",uri:"/cis308/4-chapter/4_7-ptrstoptrs_linkedlists/index.html"},{breadcrumb:"Multiple Files",description:`Our first step in writing a program with multiple files is to just divide related functions into different .c files. However, suppose we’re in our main function and we call a function from a different file? This is just like calling a C library function without using any include statements. The compiler will not know where to find the outside function.
To solve this within the C libraries, function prototypes are placed in header files (.h files). The functions themselves are implemented in corresponding .c files. If I want to use a C library function, I include the appropriate header file so that the compiler knows about the function.`,modified:"2022-09-28T11:30:45-05:00",tags:[],title:"Header Files",uri:"/cis308/5-chapter/5_1-headerfiles/index.html"},{breadcrumb:"Multiple Files",description:`It now takes three lines to compile our program, which is a pain to have to type every time we make a change. We can simplify compilation by placing all of the compilation instructions in a single file called a Makefile (with NO extension).
Here is the format of a Makefile: compiler declaration compiler flags declaration executable name declaration header list declaration object list declaration compiling/linking instruction cleaning instruction (removing output files) (There are many other options for creating Makefiles, but we will use the template above in this class.) Here is the Makefile for our statistics program`,modified:"2024-06-27T14:09:49-05:00",tags:[],title:"Makefiles",uri:"/cis308/5-chapter/5_2-makefiles/index.html"},{breadcrumb:"Multiple Files",description:`Sometimes when our program is in multiple files, we still want to define variables that are visible to each file. Here’s how to do this:
Declare the global variable in a .h file. This can either be done in a .h file with some of your function prototypes, or in a special file, globals.h, that contains the declarations of all global variables. If you do use a special globals header file, it does not need a corresponding .c file. Include the .h file wherever you want to use the variable When you want to use the variable, declare: extern type name; where type is the type of the global variable, and name is its name. The extern keyword tells the compiler not to create a new variable, but instead to find the variable name declared in another file.`,modified:"2024-06-27T14:09:49-05:00",tags:[],title:"Extern Variables",uri:"/cis308/5-chapter/5_3-externvariables/index.html"},{breadcrumb:"User-Defined Types",description:`enum provides a way to create integer constants. For instance, in Java we might declare:
public static final int GOLD = 1; public static final int SILVER = 2; public static final int BRONZE = 3; ..but really what we want is to create a “medal” type that can take on the values GOLD, SILVER, and BRONZE. Moreover, we want GOLD to mean “1”, SILVER to mean “2”, and BRONZE to mean “3”.
(Note: Java does have enums available in its latest version, which are handled very similarly to how they are in C.)`,modified:"2022-09-28T11:30:45-05:00",tags:[],title:"Enums",uri:"/cis308/6-chapter/6_1-enum/index.html"},{breadcrumb:"User-Defined Types",description:`A union is a construct in C that can hold one of several types. A union variable can only hold one value at a time, unlike a struct, but that value is not restricted to a single type.
Here’s the format for declaring a union:
union modelName { type1 name1; type2 name2; ... typeN nameN; } objectList; Here, modelName is the name of the type you’re creating, each type name is a type you want to be able to store in this union plus a name for it, and objectList is a list of variables you want to create with this union type. Both modelName and objectList are optional.`,modified:"2022-09-28T11:30:45-05:00",tags:[],title:"Unions",uri:"/cis308/6-chapter/6_2-union/index.html"},{breadcrumb:"User-Defined Types",description:`It gets a bit cumbersome to use types called struct person and enum grade. It would be much nicer to be able to call them just person or grade. With C’s typedef construct, we can do just that.
The format of typedef is:
typedef oldType newType; Here, we rename type oldType to the new name newType. We can now create variables using the name newType. For example:
typedef char letterGrade; letterGrade g; g = 'A'; Notice that we treat our new letterGrade type just like it was a char. The only difference is that when we declare the variable, we can use letterGrade as the type instead of char.`,modified:"2022-09-28T11:30:45-05:00",tags:[],title:"typedef",uri:"/cis308/6-chapter/6_3-typedef/index.html"},{breadcrumb:"User-Defined Types",description:`Consider the following struct:
typedef struct { char name[20]; int age; union { struct { char major[20]; double gpa; } student; struct { char division[20]; int yearsWorked; } employee; } type; enum {employeeK, studentK} typeK; } person; Suppose we want to create a pointer to a struct variable with the following information:
Name: Bob Jones Student Age: 18 Major: EECE GPA: 3.2 First, we’d declare a pointer of type person:`,modified:"2022-09-28T11:30:45-05:00",tags:[],title:"User-Defined Types with Pointers",uri:"/cis308/6-chapter/6_4-usertypes_w_ptrs/index.html"},{breadcrumb:"User-Defined Types",description:`The C pre-processor is a special program that runs before the C compiler. It processes every line that begins with a #, such as a #include statement. The pre-processor may add, remove, or change your code when handling the # statements.
#include We’ve been using the #include statement since our first program in order to get access to C’s library functions (like printf in stdio.h). When the pre-processor sees a #include statement, it replaces the #include line with the contents of the included file. For example, when the pre-processor sees:`,modified:"2022-09-28T11:30:45-05:00",tags:[],title:"Preprocessor Directives",uri:"/cis308/6-chapter/6_5-preprocessor/index.html"},{breadcrumb:"Pointers to Functions",description:`Declaration Syntax Here is the syntax for declaring a function pointer:
return_type (*ptr_name) (args); This declares ptr_name as a pointer to a function that returns something of type return_type and that takes the argument types described in args. Here, args is a comma-separated lists of the argument types for a function. For example, args would be (int, double) for a function that took two arguments – an int followed by a double.`,modified:"2023-04-25T07:06:01-05:00",tags:[],title:"Function Pointer Basics",uri:"/cis308/7-chapter/7_1-fnptrbasics/index.html"},{breadcrumb:"Pointers to Functions",description:`Since a function pointer is a valid type, we can pass function pointers as arguments to functions and can also return them from functions.
Passing Function Pointers to Functions Recall that the syntax for declaring a function ponter is:
return_type (*ptr_name) (args); Where ptr_name is the new variable name for a function pointer that returns something of type return_type and that takes the argument types described in args. We can similarly accept a function pointer as an argument to a function using the same syntax.`,modified:"2022-11-11T11:10:17-06:00",tags:[],title:"Functions and Function Pointers",uri:"/cis308/7-chapter/7_2-fn_fnptr/index.html"},{breadcrumb:"Pointers to Functions",description:`We can declare arrays of function pointers using the same syntax we use to create arrays of any other type. As we saw in the previous section, it is often easier to first rename our function pointer using typedef, and then to use that new type when declaring an array.
Consider our operations functions and newly created function type from the previous section:
//'function' is the name of a new function pointer type //describing a function that returns an int and takes two int arguments typedef int (*function) (int, int); int plus(int a, int b) { return a + b; } int minus(int a, int b) { return a - b; } int times(int a, int b) { return a * b; } int divide(int a, int b) { return a / b; } Since each operation function is the same type, we can create an array of these four function pointers. We can then ask the user to enter an array index corresponding to the desired operation, and access the appropriate function pointer to execute the operation:`,modified:"2022-07-25T11:05:00-05:00",tags:[],title:"Arrays of Function Pointers",uri:"/cis308/7-chapter/7_3-arraysfnptrs/index.html"},{breadcrumb:"",description:"",modified:"0001-01-01T00:00:00+00:00",tags:[],title:"Categories",uri:"/cis308/categories/index.html"},{breadcrumb:"",description:`Julie Thornton
Computer Science Department
Kansas State University
Email: juliet@ksu.edu
This is the textbook for CIS 308, C Language Lab, at Kansas State University. The course assumes students have significant programming background in a high-level language like C# or Java. It also assumes familiarity with common data structures (linked lists, stacks, queues, binary search trees, hash tables, and graphs) and their implementations.`,modified:"2023-08-10T15:07:40-05:00",tags:[],title:"CIS 308 Textbook",uri:"/cis308/index.html"},{breadcrumb:"",description:"",modified:"0001-01-01T00:00:00+00:00",tags:[],title:"Tags",uri:"/cis308/tags/index.html"}]