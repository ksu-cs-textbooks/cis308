<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content="The	pointers we	have looked	at	so	far	have	all	been	pointers	to	various	types	of	data	objects, (such	as	int,	char,	double,	struct	person,	and	pointer-to-int),	but	it	is	also	possible	to	have pointers	to	functions.	Pointers	to	functions	are	useful	for	approximately	the	same	reasons	as pointers	to	data:	when	you	want	an	extra	level	of	indirection, or	when	you’d	like	the	same	piece	of code	to	call	different	functions	depending	on	circumstances."><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary"><meta name=twitter:title content="Pointers to Functions :: CIS 308 Textbook"><meta name=twitter:description content="The	pointers we	have looked	at	so	far	have	all	been	pointers	to	various	types	of	data	objects, (such	as	int,	char,	double,	struct	person,	and	pointer-to-int),	but	it	is	also	possible	to	have pointers	to	functions.	Pointers	to	functions	are	useful	for	approximately	the	same	reasons	as pointers	to	data:	when	you	want	an	extra	level	of	indirection, or	when	you’d	like	the	same	piece	of code	to	call	different	functions	depending	on	circumstances."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis308/7-chapter/"><meta property="og:site_name" content="CIS 308 Textbook"><meta property="og:title" content="Pointers to Functions :: CIS 308 Textbook"><meta property="og:description" content="The	pointers we	have looked	at	so	far	have	all	been	pointers	to	various	types	of	data	objects, (such	as	int,	char,	double,	struct	person,	and	pointer-to-int),	but	it	is	also	possible	to	have pointers	to	functions.	Pointers	to	functions	are	useful	for	approximately	the	same	reasons	as pointers	to	data:	when	you	want	an	extra	level	of	indirection, or	when	you’d	like	the	same	piece	of code	to	call	different	functions	depending	on	circumstances."><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Pointers to Functions :: CIS 308 Textbook"><meta itemprop=description content="The	pointers we	have looked	at	so	far	have	all	been	pointers	to	various	types	of	data	objects, (such	as	int,	char,	double,	struct	person,	and	pointer-to-int),	but	it	is	also	possible	to	have pointers	to	functions.	Pointers	to	functions	are	useful	for	approximately	the	same	reasons	as pointers	to	data:	when	you	want	an	extra	level	of	indirection, or	when	you’d	like	the	same	piece	of code	to	call	different	functions	depending	on	circumstances."><meta itemprop=datePublished content="2018-08-24T10:53:05-05:00"><meta itemprop=dateModified content="2023-08-10T15:07:40-05:00"><meta itemprop=wordCount content="75"><title>Pointers to Functions :: CIS 308 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis308/7-chapter/ rel=canonical type=text/html title="Pointers to Functions :: CIS 308 Textbook"><link href=/cis308/7-chapter/index.xml rel=alternate type=application/rss+xml title="Pointers to Functions :: CIS 308 Textbook"><link href=/cis308/7-chapter/tele.html rel=alternate type=text/html title="Pointers to Functions :: CIS 308 Textbook"><link href=/cis308/7-chapter/embed.html rel=alternate type=text/html title="Pointers to Functions :: CIS 308 Textbook"><link href=/cis308/css/fontawesome-all.min.css?1737135072 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis308/css/fontawesome-all.min.css?1737135072 rel=stylesheet></noscript><link href=/cis308/css/nucleus.css?1737135072 rel=stylesheet><link href=/cis308/css/auto-complete.css?1737135072 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis308/css/auto-complete.css?1737135072 rel=stylesheet></noscript><link href=/cis308/css/perfect-scrollbar.min.css?1737135072 rel=stylesheet><link href=/cis308/css/fonts.css?1737135072 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis308/css/fonts.css?1737135072 rel=stylesheet></noscript><link href=/cis308/css/theme.css?1737135072 rel=stylesheet><link href=/cis308/css/theme-auto.css?1737135072 rel=stylesheet id=R-variant-style><link href=/cis308/css/chroma-auto.css?1737135072 rel=stylesheet id=R-variant-chroma-style><link href=/cis308/css/variant.css?1737135072 rel=stylesheet><link href=/cis308/css/print.css?1737135072 rel=stylesheet media=print><link href=/cis308/css/format-print.css?1737135072 rel=stylesheet><script src=/cis308/js/variant.js?1737135072></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis308",window.index_js_url="/cis308/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis308/css/custom.css?1737135072 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis308/7-chapter/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Pointers to Functions</span><meta itemprop=position content="1"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis308/6-chapter/6_5-preprocessor/ title="Preprocessor Directives (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis308/7-chapter/7_1-fnptrbasics/ title="Function Pointer Basics (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><article class=chapter><header class=headline></header><div class=article-subheading>Chapter 7</div><h1 id=pointers-to-functions>Pointers to Functions</h1><p>The pointers we have looked at so far have all been pointers to various types of data objects,
(such as int, char, double, struct person, and pointer-to-int), but it is also possible to have
pointers to functions. Pointers to functions are useful for approximately the same reasons as
pointers to data: when you want an extra level of indirection, or when you&rsquo;d like the same piece of
code to call different functions depending on circumstances.</p><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Pointers to Functions</h1><article class=default><header class=headline></header><h1 id=function-pointer-basics>Function Pointer Basics</h1><h2 id=declaration-syntax>Declaration Syntax</h2><p>Here is the syntax for declaring a function pointer:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>return_type (*ptr_name) (args);</span></span></code></pre></div><p>This declares <code>ptr_name</code> as a pointer to a function that returns something of type <code>return_type</code> and that takes the argument types described in <code>args</code>. Here, <code>args</code> is a comma-separated lists of the argument types for a function. For example, <code>args</code> would be <code>(int, double)</code> for a function that took two arguments &ndash; an int followed by a double.</p><p>The extra parentheses around <code>(*ptr_name)</code> are needed because there are precedence relationships in declarations just as there are in expressions. If instead we did:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//THIS IS INCORRECT FOR DECLARING A FUNCTION POINTER!
</span></span><span class=line><span class=cl>return_type *ptr_name (args);</span></span></code></pre></div><p>We would be declaring a function (NOT a function pointer) whose return type was <code>return_type*</code>.</p><h2 id=declaration-example>Declaration Example</h2><p>Suppose we wish to declare a pointer to a function that returns an int and takes two parameters &ndash; an int followed by a char*. We would write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fn_ptr</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span><span class=p>);</span></span></span></code></pre></div><p>Now <code>fn_ptr</code> is a variable of type function pointer to a function that returns an int and takes <code>(int, char*)</code> as arguments.</p><h2 id=initialization-syntax>Initialization Syntax</h2><p>To initialize our <code>fn_ptr</code> variable, we need an existing function whose header matches its declaration &ndash; one that returns an int and takes <code>(int, char*)</code> as arguments. Suppose we have the following function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>addToLength</span><span class=p>(</span><span class=kt>int</span> <span class=n>num</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span> <span class=n>str</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>num</span> <span class=o>+</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Suppose we also have our <code>fn_ptr</code> variable declared in a main method. Now we can initialize <code>fn_ptr</code> to point to the beginning of the executable code in the <code>addToLength</code> function.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>test</span> <span class=o>=</span> <span class=s>&#34;hello&#34;</span><span class=p>;</span>       <span class=c1>//declares string constant &#34;hello&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fn_ptr</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span><span class=p>);</span>  <span class=c1>//declares our function pointer, fn_ptr
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>fn_ptr</span> <span class=o>=</span> <span class=n>addToLength</span><span class=p>;</span>       <span class=c1>//now fn_ptr points to the addToLength function
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Note that when we do:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>fn_ptr</span> <span class=o>=</span> <span class=n>addToLength</span><span class=p>;</span></span></span></code></pre></div><p>That we mean: assign to <code>fn_ptr</code> the memory address of the beginning of the executable code in the <code>addToLength</code> function. We could have more pedantically written:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>fn_ptr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>addToLength</span><span class=p>;</span></span></span></code></pre></div><p>To explicitly get the memory address of the <code>addToLength</code> function, and assign that to <code>fn_ptr</code>. However, the <code>&</code> is optional in this case since there is no other way to interpret assigning to a function pointer variable.</p><h2 id=using-function-pointers>Using Function Pointers</h2><p>After you have declared and initialized a function pointer variable, you can use it to call the referenced function (passing the necessary arguments). In our example, we could modify our main method to look like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>result</span><span class=p>;</span>                 <span class=c1>//declare result variable
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>test</span> <span class=o>=</span> <span class=s>&#34;hello&#34;</span><span class=p>;</span>       <span class=c1>//declares string constant &#34;hello&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fn_ptr</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>char</span><span class=o>*</span><span class=p>);</span>  <span class=c1>//declares our function pointer, fn_ptr
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>fn_ptr</span> <span class=o>=</span> <span class=n>addToLength</span><span class=p>;</span>       <span class=c1>//now fn_ptr points to the addToLength function
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ans</span> <span class=o>=</span> <span class=nf>fn_ptr</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=n>test</span><span class=p>);</span>  <span class=c1>//call the function referenced by fn_ptr,
</span></span></span><span class=line><span class=cl><span class=c1></span>                                <span class=c1>//passing 3 and test. Store the returned value
</span></span></span><span class=line><span class=cl><span class=c1></span>                                <span class=c1>//in the ans variable
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ans</span><span class=p>);</span>     <span class=c1>//in our example, prints 8
</span></span></span><span class=line><span class=cl><span class=c1></span>                                <span class=c1>//(the length of &#34;hello&#34; plus 3)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Note that we use <code>fn_ptr</code> as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>ans</span> <span class=o>=</span> <span class=nf>fn_ptr</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=n>test</span><span class=p>);</span></span></span></code></pre></div><p>This calls the function referenced by <code>fn_ptr</code> (the <code>addToLength</code> function), passing the arguments 3 and <code>test</code>. The value returned by the referenced (<code>addToLength</code>) function is stored in the <code>ans</code> variable.</p><p>The <code>fn_ptr</code> variable holds the memory address of the beginning of the executable code for the <code>addToLength</code> function. When we do <code>int ans = fn_ptr(3, test)</code>, we want to go to the memory location stored in <code>fn_ptr</code>, and begin executing that code. In other words, we wish to dereference <code>fn_ptr</code>, which we can do with the <code>*</code> operator. We could more precisely write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=n>ans</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=n>fn_ptr</span><span class=p>)(</span><span class=mi>3</span><span class=p>,</span> <span class=n>test</span><span class=p>);</span></span></span></code></pre></div><p>To first go to the executable code referenced by <code>fn_ptr</code>, and then to start executing that code with arguments <code>3</code> and <code>test</code>. As with using the <code>&</code> operator when initializing function pointers, using the dereferencing operator when using a function pointer is optional. There is no other possible meaning of <code>fn_ptr(3, test)</code>, so the function pointer is dereferenced whether we explicitly use the operator or not.</p><p>If we do choose to explicitly dereference, we need to be careful with order of operations. If we instead did:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//THIS IS INCORRECT FOR USING A FUNCTION POINTER!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>ans</span> <span class=o>=</span> <span class=o>*</span><span class=nf>fn_ptr</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=n>test</span><span class=p>);</span></span></span></code></pre></div><p>Then we would first go to the executable code referenced by <code>fn_ptr</code> (the <code>addToLength</code> function), passing our arguments <code>3</code> and <code>test</code>. That code would return <code>8</code>, which is the sum of and the argument <code>3</code> and the string length of <code>hello</code>. Finally, we would assign to <code>ans</code> the result of dereferencing the <code>8</code>. This will lead to either a segmentation fault (the program crashing) or to grabbing an arbirtrary value in memory and claiming it as our answer.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=functions-and-function-pointers>Functions and Function Pointers</h1><p>Since a function pointer is a valid type, we can pass function pointers as arguments to functions and can also return them from functions.</p><h2 id=passing-function-pointers-to-functions>Passing Function Pointers to Functions</h2><p>Recall that the syntax for declaring a function ponter is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>return_type (*ptr_name) (args);</span></span></code></pre></div><p>Where <code>ptr_name</code> is the new variable name for a function pointer that returns something of type <code>return_type</code> and that takes the argument types described in <code>args</code>. We can similarly accept a function pointer as an argument to a function using the same syntax.</p><p>For example, consider the following program:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>plus</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>minus</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>-</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>times</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>*</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>divide</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>/</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//op is a function pointer to a function that takes two integer arguments
</span></span></span><span class=line><span class=cl><span class=c1>//and returns an integer result
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>doOperation</span><span class=p>(</span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>op</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>),</span> <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//calls the function pointed to by op and returns the result
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nf>op</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>num1</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>num2</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Added result: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>doOperation</span><span class=p>(</span><span class=n>plus</span><span class=p>,</span> <span class=n>num1</span><span class=p>,</span> <span class=n>num2</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Multiplied result: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>doOperation</span><span class=p>(</span><span class=n>times</span><span class=p>,</span> <span class=n>num1</span><span class=p>,</span> <span class=n>num2</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>The code above will print:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Added result: 7
</span></span><span class=line><span class=cl>Multiplied result: 12</span></span></code></pre></div><p>The above example might seem unnecessarily complicated, as we could have directly called <code>plus</code> and <code>times</code> from <code>main</code> and bypassed the <code>doOperation</code> function altogether. However, using function pointers as arguments can be very powerful &ndash; for example, the <code>stdlib</code> library defines a <code>qsort</code> function that accepts a comparator function pointer as an argument. This way, we can use the same sorting function to sort in a variety of ways &ndash; ascending order, descending order, by length, etc. &ndash; by passing in a different comparator function pointer.</p><h2 id=typedef-and-function-pointers>Typedef and Function Pointers</h2><p>Listing the type of function pointers can be tedious and error-prone. It can be much easier to use <code>typedef</code> once to create a new (more simply named) type representing a particular kind of function pointer, and then use the new type name after that. For example, in our math operations program above, we can first create a new type name for our function pointer type:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=nf>int</span> <span class=p>(</span><span class=o>*</span><span class=n>function</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span></span></span></code></pre></div><p>This creates a new type called <code>function</code> that represents a function pointer to a function that returns an int and takes two int arguments. We can then use the type <code>function</code> in our <code>doOperation</code> method instead of writing out the argument <code>int (*op)(int, int)</code>. Here is the new <code>doOperation</code> function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>doOperation</span><span class=p>(</span><span class=n>function</span> <span class=n>op</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//calls the function pointed to by op and returns the result
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=nf>op</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Note that the type name <code>function</code> can be anything &ndash; this is just the new type name we happened to pick when using <code>typedef</code>.</p><h2 id=returning-function-pointers-from-functions>Returning Function Pointers from Functions</h2><p>Returning function pointers from functions is exactly the same idea as returning any other other type from a function. Ideally, we would first use <code>typedef</code> to create a new type name for the desired type of function pointer. For example, we could add a new function to our operations example above that returns a pointer to the correct operation function based on a char argument:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>function</span> <span class=nf>getOperation</span><span class=p>(</span><span class=kt>char</span> <span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=sc>&#39;+&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>plus</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=sc>&#39;-&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>minus</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=sc>&#39;*&#39;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>times</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//will return &#39;divide&#39; if a non-operation char argument
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//is passed
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>divide</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Then, we could use our <code>getOperation</code> function to get the correct operation based on user input:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>op</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>num1</span><span class=p>,</span> <span class=n>num2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Enter number op number (no spaces, like 3+2): &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%d%c%d&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>num1</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>op</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>num2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>function</span> <span class=n>opResult</span> <span class=o>=</span> <span class=nf>getOperation</span><span class=p>(</span><span class=n>op</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Result: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>opResult</span><span class=p>(</span><span class=n>num1</span><span class=p>,</span> <span class=n>num2</span><span class=p>));</span></span></span></code></pre></div><p>By saving the correct operation function in <code>opResult</code>, we could then call <code>opResult</code> (which would call either <code>plus</code>, <code>minus</code>, <code>times</code>, or <code>divide</code> based on the value of <code>op</code>) to get the result of the operation.</p><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=arrays-of-function-pointers>Arrays of Function Pointers</h1><p>We can declare arrays of function pointers using the same syntax we use to create arrays of any other type. As we saw in the previous section, it is often easier to first rename our function pointer using <code>typedef</code>, and then to use that new type when declaring an array.</p><p>Consider our operations functions and newly created <code>function</code> type from the previous section:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//&#39;function&#39; is the name of a new function pointer type
</span></span></span><span class=line><span class=cl><span class=c1>//describing a function that returns an int and takes two int arguments
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=nf>int</span> <span class=p>(</span><span class=o>*</span><span class=n>function</span><span class=p>)</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>plus</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>minus</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>-</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>times</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>*</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>divide</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>/</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Since each operation function is the same type, we can create an array of these four function pointers. We can then ask the user to enter an array index corresponding to the desired operation, and access the appropriate function pointer to execute the operation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>num1</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>num2</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>choice</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//declares an array of four function pointers
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>function</span> <span class=n>allOps</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=n>plus</span><span class=p>,</span> <span class=n>minus</span><span class=p>,</span> <span class=n>times</span><span class=p>,</span> <span class=n>divide</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Enter 0 for plus, 1 for minus, 2 for times, and 3 for divide: &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>choice</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Result: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>allOps</span><span class=p>[</span><span class=n>choice</span><span class=p>])(</span><span class=n>num1</span><span class=p>,</span> <span class=n>num2</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Here, <code>allOps[choice]</code> accesses a particular function pointer by array index, and then calls that function (passing <code>num1</code> and <code>num2</code>). For example, if the user entered <code>2</code>, then <code>allOps[choice]</code> would access the <code>times</code> function. The code would print:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Result: 12</span></span></code></pre></div><p>Since <code>times(num1, num2)</code> would return 12.</p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis308/commit/67149f1b1c3dfffeaf11fa09cef14508de147aac>Aug 10, 2023</a></p></div></div><script src=/cis308/js/clipboard.min.js?1737135072 defer></script><script src=/cis308/js/perfect-scrollbar.min.js?1737135072 defer></script><script src=/cis308/js/theme.js?1737135072 defer></script></body></html>