<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=print><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis308/images/hero.png"><meta name=twitter:title content="Structs :: CIS 308 Textbook"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis308/4-chapter/index.html"><meta property="og:site_name" content="CIS 308 Textbook"><meta property="og:title" content="Structs :: CIS 308 Textbook"><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis308/images/hero.png"><meta itemprop=name content="Structs :: CIS 308 Textbook"><meta itemprop=datePublished content="2018-08-24T10:53:05-05:00"><meta itemprop=dateModified content="2023-08-10T15:07:40-05:00"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis308/images/hero.png"><title>Structs :: CIS 308 Textbook</title><link href=https://textbooks.cs.ksu.edu/cis308/4-chapter/index.html rel=canonical type=text/html title="Structs :: CIS 308 Textbook"><link href=/cis308/4-chapter/index.xml rel=alternate type=application/rss+xml title="Structs :: CIS 308 Textbook"><link href=/cis308/4-chapter/tele.html rel=alternate type=text/html title="Structs :: CIS 308 Textbook"><link href=/cis308/4-chapter/embed.html rel=alternate type=text/html title="Structs :: CIS 308 Textbook"><link href=/cis308/css/auto-complete/auto-complete.min.css?1755623839 rel=stylesheet><script src=/cis308/js/auto-complete/auto-complete.min.js?1755623839 defer></script><script src=/cis308/js/search-lunr.min.js?1755623839 defer></script><script src=/cis308/js/search.min.js?1755623839 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis308/searchindex.en.js?1755623839"</script><script src=/cis308/js/lunr/lunr.min.js?1755623839 defer></script><script src=/cis308/js/lunr/lunr.stemmer.support.min.js?1755623839 defer></script><script src=/cis308/js/lunr/lunr.multi.min.js?1755623839 defer></script><script src=/cis308/js/lunr/lunr.en.min.js?1755623839 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis308/fonts/fontawesome/css/fontawesome-all.min.css?1755623839 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis308/fonts/fontawesome/css/fontawesome-all.min.css?1755623839 rel=stylesheet></noscript><link href=/cis308/css/perfect-scrollbar/perfect-scrollbar.min.css?1755623839 rel=stylesheet><link href=/cis308/css/theme.min.css?1755623839 rel=stylesheet><link href=/cis308/css/format-print.min.css?1755623839 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/4-chapter/index.html",window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis308",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis308/css/custom.css?1755623839 rel=stylesheet></head><body class="mobile-support print" data-url=/cis308/4-chapter/index.html><div id=tele class="tele mirror"><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable 4-chapter" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=structs>Structs</h1><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Structs</h1><article class=default><header class=headline></header><h1 id=struct-syntax>Struct Syntax</h1><p>C is a procedural programming language, which means that a program is just a collection of
functions – no classes. However, C does have a construct called a struct that is similar to a data
class in Java. A struct is simply a new variable type that is a collection of related data.</p><h2 id=syntax>Syntax</h2><p>Here is the format of a struct declaration:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>struct name {
</span></span><span style=display:flex><span>    type1 name1;
</span></span><span style=display:flex><span>    type2 name2;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>} objList;</span></span></code></pre></div><p>Here, <code>name</code> is the optional name for this structure type. This name is needed if you plan to
created any variables of this struct type.
The <code>type name</code> elements are fields that you want in your struct. For example, if the struct
represented a person, you might want these fields:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> age;</span></span></code></pre></div><p>Fields in structs are the same idea as fields in a Java or C# class.</p><p>Finally, <code>objList</code> is an optional
list of variable names you want constructed with this struct type.</p><h2 id=first-example>First Example</h2><p>Here is a simple struct:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>} p1, p2;</span></span></code></pre></div><p>Now, <code>struct person</code> is a new datatype. <code>p1</code> and <code>p2</code> are variables of type <code>struct person</code>.</p><h2 id=declaring-struct-variables>Declaring Struct Variables</h2><p>You can automatically declare struct variables by listing variable names at the end of the struct
definition. You can also declare them outside the definition just like you do ordinary variables.
The format for declaring variables in C is:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>type name;</span></span></code></pre></div><p>The type of the above struct, for example, is <code>struct person</code>. So we can declare another
struct variable as follows:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> person p3;</span></span></code></pre></div><p>This declaration automatically allocates space for the struct, including space for every field in the
struct.</p><h2 id=accessing-struct-fields>Accessing Struct Fields</h2><p>Accessing a field in a struct variable is exactly like accessing a field in a Java or C#
object:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>structVar.fieldName</span></span></code></pre></div><p>Here, <code>structVar</code> is the name of the struct variable and <code>fieldName</code> is one of the fields in the
struct. This allows us to access or change that field.
Let&rsquo;s declare another struct person variable, and set the person&rsquo;s name to &ldquo;Bob&rdquo; and age to 20.</p><p>Here&rsquo;s how:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> person bobPerson;        <span style=color:#75715e>//declare struct variable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>bobPerson.age <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;             <span style=color:#75715e>//set person&#39;s age to 20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>strcpy</span>(bobPerson.name, <span style=color:#e6db74>&#34;Bob&#34;</span>);  <span style=color:#75715e>//set person&#39;s name to &#34;Bob&#34;
</span></span></span></code></pre></div><p>Notice that if we are initializing a string field, we must use <code>strcpy</code>. The following will NOT
compile since name is an array (a constant pointer):</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>bobPerson.name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Bob&#34;</span>;         <span style=color:#75715e>//Will not compile!
</span></span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=struct-example>Struct Example</h1><p>Structs can be declared at any point in a C program, but they are usually declared with the global
variables (right after the include statements). This way, the struct type can be used throughout
the file.</p><p>Here is an example that uses a struct to store a two-dimensional point (x, y location). It gets two
points as input, and then prints the equation that passes through the points.</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> y;
</span></span><span style=display:flex><span>}; <span style=color:#75715e>//No variables declared here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getSlope</span>(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getIntercept</span>(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>double</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> point p1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> point p2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> slope;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> intercept;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Enter point1, e.g. (1, 2): &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;(%d, %d)&#34;</span>, <span style=color:#f92672>&amp;</span>(p1.x), <span style=color:#f92672>&amp;</span>(p1.y));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Enter point2, e.g. (1, 2): &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;(%d, %d)&#34;</span>, <span style=color:#f92672>&amp;</span>(p2.x), <span style=color:#f92672>&amp;</span>(p2.y));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    slope <span style=color:#f92672>=</span> <span style=color:#a6e22e>getSlope</span>(p1.x, p1.y, p2.x, p2.y);
</span></span><span style=display:flex><span>    intercept <span style=color:#f92672>=</span> <span style=color:#a6e22e>getIntercept</span>(p1.x, p1.y, slope);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//prints equation in form y = mx + b
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//m: slope, b: y-intercept
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;y = %.2lfx + %.2lf</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, slope, intercept);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getSlope</span>(<span style=color:#66d9ef>int</span> x1, <span style=color:#66d9ef>int</span> x2, <span style=color:#66d9ef>int</span> y1, <span style=color:#66d9ef>int</span> y2) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//slope = change in y / change in x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> (y2<span style=color:#f92672>-</span>y1)<span style=color:#f92672>/</span>(x2<span style=color:#f92672>-</span>x1);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getIntercept</span>(<span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>int</span> y, <span style=color:#66d9ef>double</span> slope) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//if y = mx + b, b = y - mx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> y <span style=color:#f92672>-</span> slope<span style=color:#f92672>*</span>x;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=structs-and-functions>Structs and Functions</h1><p>We could have also written the <a href=https://textbooks.cs.ksu.edu/cis308/4-chapter/4_2-structexample/ rel=external target=_blank>point example</a>
by passing the point structs to the <code>getSlope</code> and
<code>getIntercept</code> functions (instead of passing their fields). This works just like passing other
variable types, except <code>struct point</code> will be an argument type.
Here&rsquo;s the example when we pass the points to the functions:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> point {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> y;
</span></span><span style=display:flex><span>}; <span style=color:#75715e>//No variables declared here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getSlope</span>(<span style=color:#66d9ef>struct</span> point, <span style=color:#66d9ef>struct</span> point);
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getIntercept</span>(<span style=color:#66d9ef>struct</span> point, <span style=color:#66d9ef>double</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> point p1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> point p2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> slope;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> intercept;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Enter point1, e.g. (1, 2): &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;(%d, %d)&#34;</span>, <span style=color:#f92672>&amp;</span>(p1.x), <span style=color:#f92672>&amp;</span>(p1.y));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Enter point2, e.g. (1, 2): &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;(%d, %d)&#34;</span>, <span style=color:#f92672>&amp;</span>(p2.x), <span style=color:#f92672>&amp;</span>(p2.y));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    slope <span style=color:#f92672>=</span> <span style=color:#a6e22e>getSlope</span>(p1, p2);
</span></span><span style=display:flex><span>    intercept <span style=color:#f92672>=</span> <span style=color:#a6e22e>getIntercept</span>(p1, slope);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//prints equation in form y = mx + b
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//m: slope, b: y-intercept
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;y = %.2lfx + %.2lf</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, slope, intercept);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getSlope</span>(<span style=color:#66d9ef>struct</span> point p1, <span style=color:#66d9ef>struct</span> point p2) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//slope = change in y / change in x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> (p2.y<span style=color:#f92672>-</span>p1.y)<span style=color:#f92672>/</span>(p2.x<span style=color:#f92672>-</span>p1.x);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>getIntercept</span>(<span style=color:#66d9ef>struct</span> point p, <span style=color:#66d9ef>double</span> slope) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//if y = mx + b, b = y - mx
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> p.y <span style=color:#f92672>-</span> slope<span style=color:#f92672>*</span>p.x;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=arrays-of-structs>Arrays of Structs</h1><p>You can create arrays of structs in C just like you can create arrays of any other type. The format for creating constant-sized arrays is:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>type name[size];</span></span></code></pre></div><p>Consider the person struct again:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>};</span></span></code></pre></div><p>Here&rsquo;s how to create a 3-slot array of type <code>struct person</code> called <code>group</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>//&#34;struct person&#34; is the type; &#34;group&#34; is the array name
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> person group[<span style=color:#ae81ff>3</span>];</span></span></code></pre></div><p>When you create an array of type struct, C allocates space for each struct element (and its fields)
in the array.</p><p>We can get out a particular struct element using an array index:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>group[<span style=color:#ae81ff>0</span>]        <span style=color:#75715e>//the first struct person in the array
</span></span></span></code></pre></div><p>For example, here&rsquo;s how we could set the first person&rsquo;s name to &ldquo;Bob&rdquo; and age to 20:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>strcpy</span>(group[<span style=color:#ae81ff>0</span>].name, <span style=color:#e6db74>&#34;Bob&#34;</span>);
</span></span><span style=display:flex><span>group[<span style=color:#ae81ff>0</span>].age <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pointers-to-structs>Pointers to Structs</h1><p>You can declare a pointer to a struct just like you declare a pointer to another element type. The
format for declaring a pointer is:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>type* name;</span></span></code></pre></div><p>So, to declare a pointer to a <code>struct person</code> element, we could say:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> person<span style=color:#f92672>*</span> personPtr;</span></span></code></pre></div><p>Suppose we have another <code>struct person</code> variable:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> person p1;
</span></span><span style=display:flex><span><span style=color:#a6e22e>strcpy</span>(p1.name, <span style=color:#e6db74>&#34;Jill&#34;</span>);
</span></span><span style=display:flex><span>p1.age <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span>;</span></span></code></pre></div><p>Then we can make <code>personPtr</code> point to <code>p1</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>personPtr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>p1;</span></span></code></pre></div><h2 id=allocating-memory>Allocating Memory</h2><p>We can also create struct variables by:</p><ol><li>Declaring a pointer to a struct</li><li>Allocating memory for the struct</li></ol><p>This approach (using pointers instead of standard variables) is handy when building data
structures like linked lists.</p><p>To create a struct person in this way, we first declare a pointer:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> person<span style=color:#f92672>*</span> personPtr;</span></span></code></pre></div><p>Then we allocate memory for the struct, and give <code>personPtr</code> the address of that memory. We
can use <code>sizeof(struct person)</code> to get the number of bytes needed to store a variable of
type <code>struct person</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>personPtr <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> person));</span></span></code></pre></div><p>Now, <code>personPtr</code> points to a <code>struct person</code>, which has space for the <code>name</code> and <code>age</code> fields.</p><h2 id=accessing-fields>Accessing Fields</h2><p>We can get at the struct person object itself by dereferencing <code>personPtr</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#f92672>*</span>personPtr</span></span></code></pre></div><p>We can then initialize the fields:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>(<span style=color:#f92672>*</span>personPtr).age <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span>;</span></span></code></pre></div><p>This line does two things:</p><ol><li>Dereferences the pointer to get at the <code>struct person</code> object</li><li>Changes the person’s age to 18</li></ol><p>Do NOT write something like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#f92672>*</span>personPtr.age <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span>;    <span style=color:#75715e>//BAD!
</span></span></span></code></pre></div><p>The compiler will try to resolve the &ldquo;.&rdquo; operator first. Because <code>personPtr</code> is a pointer and not
a struct, using a . doesn’t make sense. This line will result in a compiler error. We need to
dereference the pointer before we can access any fields.</p><p>Pointers to structs are very common in C, and you’ll often find yourself dereferencing a struct
pointer and then accessing one of the fields. Because of this, there is a shortcut notation:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>personPtr<span style=color:#f92672>-&gt;</span>age <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//Is equivalent to:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>(<span style=color:#f92672>*</span>personPtr).age <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span>;</span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=linked-lists>Linked Lists</h1><p>We can use structs to help implement all the common data structures in C. For example,
whereas before we would have created a Node class to help us write a linked list, we will now
create a node struct:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> node {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>next; <span style=color:#75715e>//pointer to next node in list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};</span></span></code></pre></div><p>Suppose we want to create a linked list with a single node. First, we declare a head variable:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>head;</span></span></code></pre></div><p>Then, we allocate memory for the node:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>head <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> node));</span></span></code></pre></div><p>Finally, we initialize the fields in <code>head</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>head<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> NULL;</span></span></code></pre></div><p>Here&rsquo;s a full C program that inserts values into a linked list and then prints them out:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> node {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>head;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    head <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//prints 1, 2, 3, 4 on separate lines
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>print</span>();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> num) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//create new node
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>newnode <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>struct</span> node));
</span></span><span style=display:flex><span>    newnode<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> num;
</span></span><span style=display:flex><span>    newnode<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (head <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>        head <span style=color:#f92672>=</span> newnode;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//find end of list
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>cur <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (cur<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>            cur <span style=color:#f92672>=</span> cur<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//add newnode after cur
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        cur<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> newnode;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>cur <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (cur <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, cur<span style=color:#f92672>-&gt;</span>data);
</span></span><span style=display:flex><span>        cur <span style=color:#f92672>=</span> cur<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>Linked lists in C work almost exactly the same as linked lists in Java or C#. The only differences are:</p><ol><li>We use a struct instead of a class to represent a node</li><li>We use -> instead of . to access values in the node</li></ol><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pointers-to-pointers-in-linked-lists>Pointers to Pointers in Linked Lists</h1><p>Let&rsquo;s look at how pointers to pointers can be used to eliminate a nuisance we&rsquo;ve had when trying to
insert and delete items in linked lists. For simplicity, we&rsquo;ll consider lists of integers, built using this
structure:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> node {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span> };</span></span></code></pre></div><p>Suppose we&rsquo;re trying to write some code to delete a given integer from a list. The straightforward
solution looks like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>//delete node containing i from list pointed to by lp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>lp, <span style=color:#f92672>*</span>prevlp;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(lp <span style=color:#f92672>=</span> list; lp <span style=color:#f92672>!=</span> NULL; lp <span style=color:#f92672>=</span> lp<span style=color:#f92672>-&gt;</span>next) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(lp<span style=color:#f92672>-&gt;</span>item <span style=color:#f92672>==</span> i) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(lp <span style=color:#f92672>==</span> list)
</span></span><span style=display:flex><span>            list <span style=color:#f92672>=</span> lp<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            prevlp<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> lp<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    prevlp <span style=color:#f92672>=</span> lp;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>This code works, but it has two flaws. One is that it must use an extra variable to keep track of the
node behind the one it&rsquo;s looking at, and the other is that it must use an extra test to special-case the
situation in which the node being deleted is at the head of the list. Both problems arise because the
deletion of a node from the list involves modifying the previous pointer to point to the next node (that
is, the node before the deleted node to point to the one following). But, depending on whether the node
being deleted is the first node in the list or not, the pointer that needs modifying is either the pointer
that points to the head of the list, or the next pointer in the previous node.</p><p>To illustrate this, suppose that we have the list (1, 2, 3) and we&rsquo;re trying to delete the element 1. After
we&rsquo;ve found the element 1, <code>lp</code> points to its node, which just happens to be the same node that the
main list pointer points to, as illustrated in (a) below:</p><p><a href=#R-image-b905121591e8b4c15f0fec1901c03dac class=lightbox-link><img alt=linkedlistA class="border lazy lightbox figure-image" loading=lazy src=/cis308/images/linkedListA.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-b905121591e8b4c15f0fec1901c03dac><img alt=linkedlistA class="border lazy lightbox lightbox-image" loading=lazy src=/cis308/images/linkedListA.png></a></p><p>To remove element 1 from the list, then, we must adjust the main list pointer so that it points to 2&rsquo;s
node, the new head of the list (as shown in (b) below):</p><p><a href=#R-image-fc1ae52fe2d3467931cd3270492f9b33 class=lightbox-link><img alt=linkedlistB class="border lazy lightbox figure-image" loading=lazy src=/cis308/images/linkedListB.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-fc1ae52fe2d3467931cd3270492f9b33><img alt=linkedlistB class="border lazy lightbox lightbox-image" loading=lazy src=/cis308/images/linkedListB.png></a></p><p>If we were trying to delete node 2, on the other hand (as illustrated in (c) below):</p><p><a href=#R-image-199f697d4528ba5050e6a04f6504ca66 class=lightbox-link><img alt=linkedlistC class="border lazy lightbox figure-image" loading=lazy src=/cis308/images/linkedListC.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-199f697d4528ba5050e6a04f6504ca66><img alt=linkedlistC class="border lazy lightbox lightbox-image" loading=lazy src=/cis308/images/linkedListC.png></a></p><p>we&rsquo;d have to adjust node 1&rsquo;s next pointer to point to 3.</p><p>The <code>prevlp</code> pointer keeps track of the previous node we were looking at, since (at other than the first node in the
list) that&rsquo;s the node whose next pointer will need adjusting. (Notice that if we were to delete node 3, we
would copy its next pointer over to 2, but since 3&rsquo;s next pointer is the null pointer, copying it to node 2
would make node 2 the end of the list, as desired.)</p><p>There is another way to write the list-deletion code, which is (in some ways, at least)
much cleaner, by using a pointer to a pointer to a <code>struct node</code>.</p><p>Hint: This pointer will point at the pointer which points at the node we&rsquo;re looking at; it will either
point at the head pointer or at the next pointer of the node we looked at last time. Since this pointer
points at the pointer that points at the node we&rsquo;re looking at, it points at the pointer which
we need to modify if the node we&rsquo;re looking at is the node we&rsquo;re deleting.</p><footer class=footline></footer></article></section></div></main></div><script src=/cis308/js/clipboard/clipboard.min.js?1755623839 defer></script><script src=/cis308/js/perfect-scrollbar/perfect-scrollbar.min.js?1755623839 defer></script><script src=/cis308/js/theme.min.js?1755623839 defer></script></div><script src=/cis308/js/tele-scroll.min.js?1755623839 defer></script></body></html>