<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.128.0"><meta name=generator content="Relearn 6.0.0"><meta name=description content><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary"><meta name=twitter:title content="Structs :: CIS 308 Textbook"><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis308/4-chapter/"><meta property="og:site_name" content="CIS 308 Textbook"><meta property="og:title" content="Structs :: CIS 308 Textbook"><meta property="og:locale" content="en-us"><meta property="og:type" content="website"><meta itemprop=name content="Structs :: CIS 308 Textbook"><meta itemprop=datePublished content="2018-08-24T10:53:05-05:00"><meta itemprop=dateModified content="2023-08-10T15:07:40-05:00"><title>Structs :: CIS 308 Textbook</title>
<link href=https://textbooks.cs.ksu.edu/cis308/4-chapter/ rel=canonical type=text/html title="Structs :: CIS 308 Textbook"><link href=/cis308/4-chapter/index.xml rel=alternate type=application/rss+xml title="Structs :: CIS 308 Textbook"><link href=/cis308/4-chapter/tele.html rel=alternate type=text/html title="Structs :: CIS 308 Textbook"><link href=/cis308/4-chapter/embed.html rel=alternate type=text/html title="Structs :: CIS 308 Textbook"><link href=/cis308/css/fontawesome-all.min.css?1719515427 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis308/css/fontawesome-all.min.css?1719515427 rel=stylesheet></noscript><link href=/cis308/css/nucleus.css?1719515427 rel=stylesheet><link href=/cis308/css/auto-complete.css?1719515427 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis308/css/auto-complete.css?1719515427 rel=stylesheet></noscript><link href=/cis308/css/perfect-scrollbar.min.css?1719515427 rel=stylesheet><link href=/cis308/css/fonts.css?1719515427 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis308/css/fonts.css?1719515427 rel=stylesheet></noscript><link href=/cis308/css/theme.css?1719515427 rel=stylesheet><link href=/cis308/css/theme-auto.css?1719515427 rel=stylesheet id=R-variant-style><link href=/cis308/css/chroma-auto.css?1719515427 rel=stylesheet id=R-variant-chroma-style><link href=/cis308/css/variant.css?1719515427 rel=stylesheet><link href=/cis308/css/print.css?1719515427 rel=stylesheet media=print><link href=/cis308/css/format-print.css?1719515427 rel=stylesheet><script src=/cis308/js/variant.js?1719515427></script><script>window.relearn=window.relearn||{},window.relearn.relBasePath="..",window.relearn.relBaseUri="../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis308",window.index_js_url="/cis308/index.search.js",window.variants&&variants.init(["auto","light-theme","dark-theme"]),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`</script><link href=/cis308/css/custom.css?1719515427 rel=stylesheet></head><body class="mobile-support print disableInlineCopyToClipboard" data-url=/cis308/4-chapter/><div id=R-body class=default-animation><div id=R-body-overlay></div><nav id=R-topbar><div class=topbar-wrapper><div class=topbar-sidebar-divider></div><div class="topbar-area topbar-area-start" data-area=start><div class="topbar-button topbar-button-sidebar" data-content-empty=disable data-width-s=show data-width-m=hide data-width-l=hide><button class=topbar-control onclick=toggleNav() type=button title="Menu (CTRL+ALT+n)"><i class="fa-fw fas fa-bars"></i></button></div></div><ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype=http://schema.org/BreadcrumbList><li itemscope itemtype=https://schema.org/ListItem itemprop=itemListElement><span itemprop=name>Structs</span><meta itemprop=position content="1"></li></ol><div class="topbar-area topbar-area-end" data-area=end><div class="topbar-button topbar-button-prev" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis308/3-chapter/3_9-returningptrsfromfns/ title="Returning Pointers from Functions (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a></div><div class="topbar-button topbar-button-next" data-content-empty=disable data-width-s=show data-width-m=show data-width-l=show><a class=topbar-control href=/cis308/4-chapter/4_1-structsyntax/ title="Struct Syntax (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a></div></div></div></nav><div id=R-main-overlay></div><main id=R-body-inner class="highlightable chapter narrow" tabindex=-1><div class=flex-block-wrapper><article class=chapter><header class=headline></header><div class=article-subheading>Chapter 4</div><h1 id=structs>Structs</h1><footer class=footline></footer></article><section><h1 class=a11y-only>Subsections of Structs</h1><article class=default><header class=headline></header><h1 id=struct-syntax>Struct Syntax</h1><p>C is a procedural programming language, which means that a program is just a collection of
functions – no classes. However, C does have a construct called a struct that is similar to a data
class in Java. A struct is simply a new variable type that is a collection of related data.</p><h2 id=syntax>Syntax</h2><p>Here is the format of a struct declaration:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>struct name {
</span></span><span class=line><span class=cl>    type1 name1;
</span></span><span class=line><span class=cl>    type2 name2;
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>} objList;</span></span></code></pre></div><p>Here, <code>name</code> is the optional name for this structure type. This name is needed if you plan to
created any variables of this struct type.
The <code>type name</code> elements are fields that you want in your struct. For example, if the struct
represented a person, you might want these fields:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>name</span><span class=p>[</span><span class=mi>20</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>age</span><span class=p>;</span></span></span></code></pre></div><p>Fields in structs are the same idea as fields in a Java or C# class.</p><p>Finally, <code>objList</code> is an optional
list of variable names you want constructed with this struct type.</p><h2 id=first-example>First Example</h2><p>Here is a simple struct:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>name</span><span class=p>[</span><span class=mi>20</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>p1</span><span class=p>,</span> <span class=n>p2</span><span class=p>;</span></span></span></code></pre></div><p>Now, <code>struct person</code> is a new datatype. <code>p1</code> and <code>p2</code> are variables of type <code>struct person</code>.</p><h2 id=declaring-struct-variables>Declaring Struct Variables</h2><p>You can automatically declare struct variables by listing variable names at the end of the struct
definition. You can also declare them outside the definition just like you do ordinary variables.
The format for declaring variables in C is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>type name;</span></span></code></pre></div><p>The type of the above struct, for example, is <code>struct person</code>. So we can declare another
struct variable as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>person</span> <span class=n>p3</span><span class=p>;</span></span></span></code></pre></div><p>This declaration automatically allocates space for the struct, including space for every field in the
struct.</p><h2 id=accessing-struct-fields>Accessing Struct Fields</h2><p>Accessing a field in a struct variable is exactly like accessing a field in a Java or C#
object:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>structVar</span><span class=p>.</span><span class=n>fieldName</span></span></span></code></pre></div><p>Here, <code>structVar</code> is the name of the struct variable and <code>fieldName</code> is one of the fields in the
struct. This allows us to access or change that field.
Let&rsquo;s declare another struct person variable, and set the person&rsquo;s name to &ldquo;Bob&rdquo; and age to 20.</p><p>Here&rsquo;s how:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>person</span> <span class=n>bobPerson</span><span class=p>;</span>        <span class=c1>//declare struct variable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>bobPerson</span><span class=p>.</span><span class=n>age</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>             <span class=c1>//set person&#39;s age to 20
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>strcpy</span><span class=p>(</span><span class=n>bobPerson</span><span class=p>.</span><span class=n>name</span><span class=p>,</span> <span class=s>&#34;Bob&#34;</span><span class=p>);</span>  <span class=c1>//set person&#39;s name to &#34;Bob&#34;
</span></span></span></code></pre></div><p>Notice that if we are initializing a string field, we must use <code>strcpy</code>. The following will NOT
compile since name is an array (a constant pointer):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>bobPerson</span><span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;Bob&#34;</span><span class=p>;</span>         <span class=c1>//Will not compile!
</span></span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=struct-example>Struct Example</h1><p>Structs can be declared at any point in a C program, but they are usually declared with the global
variables (right after the include statements). This way, the struct type can be used throughout
the file.</p><p>Here is an example that uses a struct to store a two-dimensional point (x, y location). It gets two
points as input, and then prints the equation that passes through the points.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>struct</span> <span class=n>point</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span> <span class=c1>//No variables declared here
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>getSlope</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>getIntercept</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>double</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>point</span> <span class=n>p1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>point</span> <span class=n>p2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>slope</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>intercept</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Enter point1, e.g. (1, 2): &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;(%d, %d)&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>p1</span><span class=p>.</span><span class=n>x</span><span class=p>),</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>p1</span><span class=p>.</span><span class=n>y</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Enter point2, e.g. (1, 2): &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;(%d, %d)&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>p2</span><span class=p>.</span><span class=n>x</span><span class=p>),</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>p2</span><span class=p>.</span><span class=n>y</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>slope</span> <span class=o>=</span> <span class=nf>getSlope</span><span class=p>(</span><span class=n>p1</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>p1</span><span class=p>.</span><span class=n>y</span><span class=p>,</span> <span class=n>p2</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>p2</span><span class=p>.</span><span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>intercept</span> <span class=o>=</span> <span class=nf>getIntercept</span><span class=p>(</span><span class=n>p1</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>p1</span><span class=p>.</span><span class=n>y</span><span class=p>,</span> <span class=n>slope</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//prints equation in form y = mx + b
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//m: slope, b: y-intercept
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;y = %.2lfx + %.2lf</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>slope</span><span class=p>,</span> <span class=n>intercept</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>getSlope</span><span class=p>(</span><span class=kt>int</span> <span class=n>x1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x2</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//slope = change in y / change in x
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=p>(</span><span class=n>y2</span><span class=o>-</span><span class=n>y1</span><span class=p>)</span><span class=o>/</span><span class=p>(</span><span class=n>x2</span><span class=o>-</span><span class=n>x1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>getIntercept</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>,</span> <span class=kt>double</span> <span class=n>slope</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//if y = mx + b, b = y - mx
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>y</span> <span class=o>-</span> <span class=n>slope</span><span class=o>*</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=structs-and-functions>Structs and Functions</h1><p>We could have also written the <a href=https://textbooks.cs.ksu.edu/cis308/4-chapter/4_2-structexample/ rel=external target=_blank>point example</a>
by passing the point structs to the <code>getSlope</code> and
<code>getIntercept</code> functions (instead of passing their fields). This works just like passing other
variable types, except <code>struct point</code> will be an argument type.
Here&rsquo;s the example when we pass the points to the functions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>point</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span> <span class=c1>//No variables declared here
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>getSlope</span><span class=p>(</span><span class=k>struct</span> <span class=n>point</span><span class=p>,</span> <span class=k>struct</span> <span class=n>point</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>getIntercept</span><span class=p>(</span><span class=k>struct</span> <span class=n>point</span><span class=p>,</span> <span class=kt>double</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>point</span> <span class=n>p1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>point</span> <span class=n>p2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>slope</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>intercept</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Enter point1, e.g. (1, 2): &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;(%d, %d)&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>p1</span><span class=p>.</span><span class=n>x</span><span class=p>),</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>p1</span><span class=p>.</span><span class=n>y</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Enter point2, e.g. (1, 2): &#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>scanf</span><span class=p>(</span><span class=s>&#34;(%d, %d)&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>p2</span><span class=p>.</span><span class=n>x</span><span class=p>),</span> <span class=o>&amp;</span><span class=p>(</span><span class=n>p2</span><span class=p>.</span><span class=n>y</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>slope</span> <span class=o>=</span> <span class=nf>getSlope</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span> <span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>intercept</span> <span class=o>=</span> <span class=nf>getIntercept</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span> <span class=n>slope</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//prints equation in form y = mx + b
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//m: slope, b: y-intercept
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;y = %.2lfx + %.2lf</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>slope</span><span class=p>,</span> <span class=n>intercept</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>getSlope</span><span class=p>(</span><span class=k>struct</span> <span class=n>point</span> <span class=n>p1</span><span class=p>,</span> <span class=k>struct</span> <span class=n>point</span> <span class=n>p2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//slope = change in y / change in x
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=p>(</span><span class=n>p2</span><span class=p>.</span><span class=n>y</span><span class=o>-</span><span class=n>p1</span><span class=p>.</span><span class=n>y</span><span class=p>)</span><span class=o>/</span><span class=p>(</span><span class=n>p2</span><span class=p>.</span><span class=n>x</span><span class=o>-</span><span class=n>p1</span><span class=p>.</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=nf>getIntercept</span><span class=p>(</span><span class=k>struct</span> <span class=n>point</span> <span class=n>p</span><span class=p>,</span> <span class=kt>double</span> <span class=n>slope</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//if y = mx + b, b = y - mx
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>p</span><span class=p>.</span><span class=n>y</span> <span class=o>-</span> <span class=n>slope</span><span class=o>*</span><span class=n>p</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=arrays-of-structs>Arrays of Structs</h1><p>You can create arrays of structs in C just like you can create arrays of any other type. The format for creating constant-sized arrays is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>type name[size];</span></span></code></pre></div><p>Consider the person struct again:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>name</span><span class=p>[</span><span class=mi>20</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></div><p>Here&rsquo;s how to create a 3-slot array of type <code>struct person</code> called <code>group</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//&#34;struct person&#34; is the type; &#34;group&#34; is the array name
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>person</span> <span class=n>group</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span></span></span></code></pre></div><p>When you create an array of type struct, C allocates space for each struct element (and its fields)
in the array.</p><p>We can get out a particular struct element using an array index:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>group</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>        <span class=c1>//the first struct person in the array
</span></span></span></code></pre></div><p>For example, here&rsquo;s how we could set the first person&rsquo;s name to &ldquo;Bob&rdquo; and age to 20:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>strcpy</span><span class=p>(</span><span class=n>group</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>name</span><span class=p>,</span> <span class=s>&#34;Bob&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>group</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>age</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span></span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pointers-to-structs>Pointers to Structs</h1><p>You can declare a pointer to a struct just like you declare a pointer to another element type. The
format for declaring a pointer is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>type* name;</span></span></code></pre></div><p>So, to declare a pointer to a <code>struct person</code> element, we could say:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>person</span><span class=o>*</span> <span class=n>personPtr</span><span class=p>;</span></span></span></code></pre></div><p>Suppose we have another <code>struct person</code> variable:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>person</span> <span class=n>p1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>strcpy</span><span class=p>(</span><span class=n>p1</span><span class=p>.</span><span class=n>name</span><span class=p>,</span> <span class=s>&#34;Jill&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>p1</span><span class=p>.</span><span class=n>age</span> <span class=o>=</span> <span class=mi>18</span><span class=p>;</span></span></span></code></pre></div><p>Then we can make <code>personPtr</code> point to <code>p1</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>personPtr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>p1</span><span class=p>;</span></span></span></code></pre></div><h2 id=allocating-memory>Allocating Memory</h2><p>We can also create struct variables by:</p><ol><li>Declaring a pointer to a struct</li><li>Allocating memory for the struct</li></ol><p>This approach (using pointers instead of standard variables) is handy when building data
structures like linked lists.</p><p>To create a struct person in this way, we first declare a pointer:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>person</span><span class=o>*</span> <span class=n>personPtr</span><span class=p>;</span></span></span></code></pre></div><p>Then we allocate memory for the struct, and give <code>personPtr</code> the address of that memory. We
can use <code>sizeof(struct person)</code> to get the number of bytes needed to store a variable of
type <code>struct person</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>personPtr</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>person</span><span class=p>));</span></span></span></code></pre></div><p>Now, <code>personPtr</code> points to a <code>struct person</code>, which has space for the <code>name</code> and <code>age</code> fields.</p><h2 id=accessing-fields>Accessing Fields</h2><p>We can get at the struct person object itself by dereferencing <code>personPtr</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=o>*</span><span class=n>personPtr</span></span></span></code></pre></div><p>We can then initialize the fields:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=p>(</span><span class=o>*</span><span class=n>personPtr</span><span class=p>).</span><span class=n>age</span> <span class=o>=</span> <span class=mi>18</span><span class=p>;</span></span></span></code></pre></div><p>This line does two things:</p><ol><li>Dereferences the pointer to get at the <code>struct person</code> object</li><li>Changes the person’s age to 18</li></ol><p>Do NOT write something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=o>*</span><span class=n>personPtr</span><span class=p>.</span><span class=n>age</span> <span class=o>=</span> <span class=mi>18</span><span class=p>;</span>    <span class=c1>//BAD!
</span></span></span></code></pre></div><p>The compiler will try to resolve the &ldquo;.&rdquo; operator first. Because <code>personPtr</code> is a pointer and not
a struct, using a . doesn’t make sense. This line will result in a compiler error. We need to
dereference the pointer before we can access any fields.</p><p>Pointers to structs are very common in C, and you’ll often find yourself dereferencing a struct
pointer and then accessing one of the fields. Because of this, there is a shortcut notation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>personPtr</span><span class=o>-&gt;</span><span class=n>age</span> <span class=o>=</span> <span class=mi>18</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//Is equivalent to:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>(</span><span class=o>*</span><span class=n>personPtr</span><span class=p>).</span><span class=n>age</span> <span class=o>=</span> <span class=mi>18</span><span class=p>;</span></span></span></code></pre></div><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=linked-lists>Linked Lists</h1><p>We can use structs to help implement all the common data structures in C. For example,
whereas before we would have created a Node class to help us write a linked list, we will now
create a node struct:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>node</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span> <span class=c1>//pointer to next node in list
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span></span></span></code></pre></div><p>Suppose we want to create a linked list with a single node. First, we declare a head variable:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>node</span> <span class=o>*</span><span class=n>head</span><span class=p>;</span></span></span></code></pre></div><p>Then, we allocate memory for the node:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>head</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>node</span><span class=p>));</span></span></span></code></pre></div><p>Finally, we initialize the fields in <code>head</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>head</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>head</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span></span></span></code></pre></div><p>Here&rsquo;s a full C program that inserts values into a linked list and then prints them out:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>node</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>node</span> <span class=o>*</span><span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>head</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>add</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>add</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>add</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>add</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//prints 1, 2, 3, 4 on separate lines
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>print</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>num</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//create new node
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>node</span> <span class=o>*</span><span class=n>newnode</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>node</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>newnode</span><span class=o>-&gt;</span><span class=n>data</span> <span class=o>=</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>newnode</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>head</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>head</span> <span class=o>=</span> <span class=n>newnode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//find end of list
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>struct</span> <span class=n>node</span> <span class=o>*</span><span class=n>cur</span> <span class=o>=</span> <span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>cur</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>//add newnode after cur
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>newnode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>node</span> <span class=o>*</span><span class=n>cur</span> <span class=o>=</span> <span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>cur</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cur</span> <span class=o>=</span> <span class=n>cur</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Linked lists in C work almost exactly the same as linked lists in Java or C#. The only differences are:</p><ol><li>We use a struct instead of a class to represent a node</li><li>We use -> instead of . to access values in the node</li></ol><footer class=footline></footer></article><article class=default><header class=headline></header><h1 id=pointers-to-pointers-in-linked-lists>Pointers to Pointers in Linked Lists</h1><p>Let&rsquo;s look at how pointers to pointers can be used to eliminate a nuisance we&rsquo;ve had when trying to
insert and delete items in linked lists. For simplicity, we&rsquo;ll consider lists of integers, built using this
structure:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>node</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>node</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=p>};</span></span></span></code></pre></div><p>Suppose we&rsquo;re trying to write some code to delete a given integer from a list. The straightforward
solution looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//delete node containing i from list pointed to by lp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>node</span> <span class=o>*</span><span class=n>lp</span><span class=p>,</span> <span class=o>*</span><span class=n>prevlp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=p>(</span><span class=n>lp</span> <span class=o>=</span> <span class=n>list</span><span class=p>;</span> <span class=n>lp</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=n>lp</span> <span class=o>=</span> <span class=n>lp</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>lp</span><span class=o>-&gt;</span><span class=n>item</span> <span class=o>==</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>lp</span> <span class=o>==</span> <span class=n>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>list</span> <span class=o>=</span> <span class=n>lp</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>prevlp</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>lp</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>prevlp</span> <span class=o>=</span> <span class=n>lp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>This code works, but it has two flaws. One is that it must use an extra variable to keep track of the
node behind the one it&rsquo;s looking at, and the other is that it must use an extra test to special-case the
situation in which the node being deleted is at the head of the list. Both problems arise because the
deletion of a node from the list involves modifying the previous pointer to point to the next node (that
is, the node before the deleted node to point to the one following). But, depending on whether the node
being deleted is the first node in the list or not, the pointer that needs modifying is either the pointer
that points to the head of the list, or the next pointer in the previous node.</p><p>To illustrate this, suppose that we have the list (1, 2, 3) and we&rsquo;re trying to delete the element 1. After
we&rsquo;ve found the element 1, <code>lp</code> points to its node, which just happens to be the same node that the
main list pointer points to, as illustrated in (a) below:</p><p><a href=#R-image-c1f3ca930b3d462e4e49839c5ea744b5 class=lightbox-link><img alt=linkedlistA class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis308/images/linkedListA.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-c1f3ca930b3d462e4e49839c5ea744b5><img alt=linkedlistA class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis308/images/linkedListA.png></a></p><p>To remove element 1 from the list, then, we must adjust the main list pointer so that it points to 2&rsquo;s
node, the new head of the list (as shown in (b) below):</p><p><a href=#R-image-d56a1deb83e7d8d4be9443a22781f2e4 class=lightbox-link><img alt=linkedlistB class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis308/images/linkedListB.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-d56a1deb83e7d8d4be9443a22781f2e4><img alt=linkedlistB class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis308/images/linkedListB.png></a></p><p>If we were trying to delete node 2, on the other hand (as illustrated in (c) below):</p><p><a href=#R-image-ee9beed58d1ad8d37a793288dc2504e7 class=lightbox-link><img alt=linkedlistC class="border lazy lightbox noshadow figure-image" loading=lazy src=/cis308/images/linkedListC.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-ee9beed58d1ad8d37a793288dc2504e7><img alt=linkedlistC class="border lazy lightbox noshadow lightbox-image" loading=lazy src=/cis308/images/linkedListC.png></a></p><p>we&rsquo;d have to adjust node 1&rsquo;s next pointer to point to 3.</p><p>The <code>prevlp</code> pointer keeps track of the previous node we were looking at, since (at other than the first node in the
list) that&rsquo;s the node whose next pointer will need adjusting. (Notice that if we were to delete node 3, we
would copy its next pointer over to 2, but since 3&rsquo;s next pointer is the null pointer, copying it to node 2
would make node 2 the end of the list, as desired.)</p><p>There is another way to write the list-deletion code, which is (in some ways, at least)
much cleaner, by using a pointer to a pointer to a <code>struct node</code>.</p><p>Hint: This pointer will point at the pointer which points at the node we&rsquo;re looking at; it will either
point at the head pointer or at the next pointer of the node we looked at last time. Since this pointer
points at the pointer that points at the node we&rsquo;re looking at, it points at the pointer which
we need to modify if the node we&rsquo;re looking at is the node we&rsquo;re deleting.</p><footer class=footline></footer></article></section></div></main><div class=git-footer><p class=theme-version-footer>6.0.0</p><p>Last modified by:
<i class='fas fa-user'></i> Russell Feldhausen
<i class='fas fa-calendar'></i> <a href=https://github.com/ksu-cs-textbooks/cis308/commit/67149f1b1c3dfffeaf11fa09cef14508de147aac>Aug 10, 2023</a></p></div></div><script src=/cis308/js/clipboard.min.js?1719515427 defer></script><script src=/cis308/js/perfect-scrollbar.min.js?1719515427 defer></script><script src=/cis308/js/theme.js?1719515427 defer></script></body></html>