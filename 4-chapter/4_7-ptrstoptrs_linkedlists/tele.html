<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="Let’s look at how pointers to pointers can be used to eliminate a nuisance we’ve had when trying to insert and delete items in linked lists. For simplicity, we’ll consider lists of integers, built using this structure:
struct node { int data; struct node *next; }; Suppose we’re trying to write some code to delete a given integer from a list. The straightforward solution looks like this:
//delete node containing i from list pointed to by lp struct node *lp, *prevlp; for(lp = list; lp != NULL; lp = lp->next) { if(lp->item == i) { if(lp == list) list = lp->next; else { prevlp->next = lp->next; } break; } prevlp = lp; } This code works, but it has two flaws. One is that it must use an extra variable to keep track of the node behind the one it’s looking at, and the other is that it must use an extra test to special-case the situation in which the node being deleted is at the head of the list. Both problems arise because the deletion of a node from the list involves modifying the previous pointer to point to the next node (that is, the node before the deleted node to point to the one following). But, depending on whether the node being deleted is the first node in the list or not, the pointer that needs modifying is either the pointer that points to the head of the list, or the next pointer in the previous node."><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis308/images/hero.png"><meta name=twitter:title content="Pointers to Pointers in Linked Lists :: CIS 308 Textbook"><meta name=twitter:description content="Let’s look at how pointers to pointers can be used to eliminate a nuisance we’ve had when trying to insert and delete items in linked lists. For simplicity, we’ll consider lists of integers, built using this structure:
struct node { int data; struct node *next; }; Suppose we’re trying to write some code to delete a given integer from a list. The straightforward solution looks like this:
//delete node containing i from list pointed to by lp struct node *lp, *prevlp; for(lp = list; lp != NULL; lp = lp->next) { if(lp->item == i) { if(lp == list) list = lp->next; else { prevlp->next = lp->next; } break; } prevlp = lp; } This code works, but it has two flaws. One is that it must use an extra variable to keep track of the node behind the one it’s looking at, and the other is that it must use an extra test to special-case the situation in which the node being deleted is at the head of the list. Both problems arise because the deletion of a node from the list involves modifying the previous pointer to point to the next node (that is, the node before the deleted node to point to the one following). But, depending on whether the node being deleted is the first node in the list or not, the pointer that needs modifying is either the pointer that points to the head of the list, or the next pointer in the previous node."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis308/4-chapter/4_7-ptrstoptrs_linkedlists/index.html"><meta property="og:site_name" content="CIS 308 Textbook"><meta property="og:title" content="Pointers to Pointers in Linked Lists :: CIS 308 Textbook"><meta property="og:description" content="Let’s look at how pointers to pointers can be used to eliminate a nuisance we’ve had when trying to insert and delete items in linked lists. For simplicity, we’ll consider lists of integers, built using this structure:
struct node { int data; struct node *next; }; Suppose we’re trying to write some code to delete a given integer from a list. The straightforward solution looks like this:
//delete node containing i from list pointed to by lp struct node *lp, *prevlp; for(lp = list; lp != NULL; lp = lp->next) { if(lp->item == i) { if(lp == list) list = lp->next; else { prevlp->next = lp->next; } break; } prevlp = lp; } This code works, but it has two flaws. One is that it must use an extra variable to keep track of the node behind the one it’s looking at, and the other is that it must use an extra test to special-case the situation in which the node being deleted is at the head of the list. Both problems arise because the deletion of a node from the list involves modifying the previous pointer to point to the next node (that is, the node before the deleted node to point to the one following). But, depending on whether the node being deleted is the first node in the list or not, the pointer that needs modifying is either the pointer that points to the head of the list, or the next pointer in the previous node."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="Structs"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2023-02-27T17:01:33-06:00"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis308/images/hero.png"><meta itemprop=name content="Pointers to Pointers in Linked Lists :: CIS 308 Textbook"><meta itemprop=description content="Let’s look at how pointers to pointers can be used to eliminate a nuisance we’ve had when trying to insert and delete items in linked lists. For simplicity, we’ll consider lists of integers, built using this structure:
struct node { int data; struct node *next; }; Suppose we’re trying to write some code to delete a given integer from a list. The straightforward solution looks like this:
//delete node containing i from list pointed to by lp struct node *lp, *prevlp; for(lp = list; lp != NULL; lp = lp->next) { if(lp->item == i) { if(lp == list) list = lp->next; else { prevlp->next = lp->next; } break; } prevlp = lp; } This code works, but it has two flaws. One is that it must use an extra variable to keep track of the node behind the one it’s looking at, and the other is that it must use an extra test to special-case the situation in which the node being deleted is at the head of the list. Both problems arise because the deletion of a node from the list involves modifying the previous pointer to point to the next node (that is, the node before the deleted node to point to the one following). But, depending on whether the node being deleted is the first node in the list or not, the pointer that needs modifying is either the pointer that points to the head of the list, or the next pointer in the previous node."><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2023-02-27T17:01:33-06:00"><meta itemprop=wordCount content="539"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis308/images/hero.png"><title>Pointers to Pointers in Linked Lists :: CIS 308 Textbook</title><link href=https://textbooks.cs.ksu.edu/cis308/4-chapter/4_7-ptrstoptrs_linkedlists/index.html rel=canonical type=text/html title="Pointers to Pointers in Linked Lists :: CIS 308 Textbook"><link href=/cis308/4-chapter/4_7-ptrstoptrs_linkedlists/index.xml rel=alternate type=application/rss+xml title="Pointers to Pointers in Linked Lists :: CIS 308 Textbook"><link href=/cis308/4-chapter/4_7-ptrstoptrs_linkedlists/index.print.html rel=alternate type=text/html title="Pointers to Pointers in Linked Lists :: CIS 308 Textbook"><link href=/cis308/4-chapter/4_7-ptrstoptrs_linkedlists/embed.html rel=alternate type=text/html title="Pointers to Pointers in Linked Lists :: CIS 308 Textbook"><link href=/cis308/css/auto-complete/auto-complete.min.css?1755623839 rel=stylesheet><script src=/cis308/js/auto-complete/auto-complete.min.js?1755623839 defer></script><script src=/cis308/js/search-lunr.min.js?1755623839 defer></script><script src=/cis308/js/search.min.js?1755623839 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis308/searchindex.en.js?1755623839"</script><script src=/cis308/js/lunr/lunr.min.js?1755623839 defer></script><script src=/cis308/js/lunr/lunr.stemmer.support.min.js?1755623839 defer></script><script src=/cis308/js/lunr/lunr.multi.min.js?1755623839 defer></script><script src=/cis308/js/lunr/lunr.en.min.js?1755623839 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis308/fonts/fontawesome/css/fontawesome-all.min.css?1755623839 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis308/fonts/fontawesome/css/fontawesome-all.min.css?1755623839 rel=stylesheet></noscript><link href=/cis308/css/perfect-scrollbar/perfect-scrollbar.min.css?1755623839 rel=stylesheet><link href=/cis308/css/theme.min.css?1755623839 rel=stylesheet><link href=/cis308/css/format-html.min.css?1755623839 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/4-chapter/4_7-ptrstoptrs_linkedlists/index.html",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis308",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis308/css/custom.css?1755623839 rel=stylesheet></head><body class="mobile-support html" data-url=/cis308/4-chapter/4_7-ptrstoptrs_linkedlists/index.html><div id=tele class="tele mirror"><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable 4-chapter" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=pointers-to-pointers-in-linked-lists>Pointers to Pointers in Linked Lists</h1><p>Let&rsquo;s look at how pointers to pointers can be used to eliminate a nuisance we&rsquo;ve had when trying to
insert and delete items in linked lists. For simplicity, we&rsquo;ll consider lists of integers, built using this
structure:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> node {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span> };</span></span></code></pre></div><p>Suppose we&rsquo;re trying to write some code to delete a given integer from a list. The straightforward
solution looks like this:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>//delete node containing i from list pointed to by lp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>lp, <span style=color:#f92672>*</span>prevlp;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(lp <span style=color:#f92672>=</span> list; lp <span style=color:#f92672>!=</span> NULL; lp <span style=color:#f92672>=</span> lp<span style=color:#f92672>-&gt;</span>next) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(lp<span style=color:#f92672>-&gt;</span>item <span style=color:#f92672>==</span> i) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(lp <span style=color:#f92672>==</span> list)
</span></span><span style=display:flex><span>            list <span style=color:#f92672>=</span> lp<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            prevlp<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> lp<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    prevlp <span style=color:#f92672>=</span> lp;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>This code works, but it has two flaws. One is that it must use an extra variable to keep track of the
node behind the one it&rsquo;s looking at, and the other is that it must use an extra test to special-case the
situation in which the node being deleted is at the head of the list. Both problems arise because the
deletion of a node from the list involves modifying the previous pointer to point to the next node (that
is, the node before the deleted node to point to the one following). But, depending on whether the node
being deleted is the first node in the list or not, the pointer that needs modifying is either the pointer
that points to the head of the list, or the next pointer in the previous node.</p><p>To illustrate this, suppose that we have the list (1, 2, 3) and we&rsquo;re trying to delete the element 1. After
we&rsquo;ve found the element 1, <code>lp</code> points to its node, which just happens to be the same node that the
main list pointer points to, as illustrated in (a) below:</p><p><a href=#R-image-b905121591e8b4c15f0fec1901c03dac class=lightbox-link><img alt=linkedlistA class="border lazy lightbox figure-image" loading=lazy src=/cis308/images/linkedListA.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-b905121591e8b4c15f0fec1901c03dac><img alt=linkedlistA class="border lazy lightbox lightbox-image" loading=lazy src=/cis308/images/linkedListA.png></a></p><p>To remove element 1 from the list, then, we must adjust the main list pointer so that it points to 2&rsquo;s
node, the new head of the list (as shown in (b) below):</p><p><a href=#R-image-fc1ae52fe2d3467931cd3270492f9b33 class=lightbox-link><img alt=linkedlistB class="border lazy lightbox figure-image" loading=lazy src=/cis308/images/linkedListB.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-fc1ae52fe2d3467931cd3270492f9b33><img alt=linkedlistB class="border lazy lightbox lightbox-image" loading=lazy src=/cis308/images/linkedListB.png></a></p><p>If we were trying to delete node 2, on the other hand (as illustrated in (c) below):</p><p><a href=#R-image-199f697d4528ba5050e6a04f6504ca66 class=lightbox-link><img alt=linkedlistC class="border lazy lightbox figure-image" loading=lazy src=/cis308/images/linkedListC.png style=height:auto;width:auto></a>
<a href=javascript:history.back(); class=lightbox-back id=R-image-199f697d4528ba5050e6a04f6504ca66><img alt=linkedlistC class="border lazy lightbox lightbox-image" loading=lazy src=/cis308/images/linkedListC.png></a></p><p>we&rsquo;d have to adjust node 1&rsquo;s next pointer to point to 3.</p><p>The <code>prevlp</code> pointer keeps track of the previous node we were looking at, since (at other than the first node in the
list) that&rsquo;s the node whose next pointer will need adjusting. (Notice that if we were to delete node 3, we
would copy its next pointer over to 2, but since 3&rsquo;s next pointer is the null pointer, copying it to node 2
would make node 2 the end of the list, as desired.)</p><p>There is another way to write the list-deletion code, which is (in some ways, at least)
much cleaner, by using a pointer to a pointer to a <code>struct node</code>.</p><p>Hint: This pointer will point at the pointer which points at the node we&rsquo;re looking at; it will either
point at the head pointer or at the next pointer of the node we looked at last time. Since this pointer
points at the pointer that points at the node we&rsquo;re looking at, it points at the pointer which
we need to modify if the node we&rsquo;re looking at is the node we&rsquo;re deleting.</p><footer class=footline></footer></article></div></main></div><script src=/cis308/js/clipboard/clipboard.min.js?1755623839 defer></script><script src=/cis308/js/perfect-scrollbar/perfect-scrollbar.min.js?1755623839 defer></script><script src=/cis308/js/theme.min.js?1755623839 defer></script></div><script src=/cis308/js/tele-scroll.min.js?1755623839 defer></script></body></html>