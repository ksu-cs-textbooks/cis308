<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pointers to Pointers in Linked Lists :: CIS 308 Textbook</title><link>https://textbooks.cs.ksu.edu/cis308/4-chapter/4_7-ptrstoptrs_linkedlists/index.html</link><description>Let’s look at how pointers to pointers can be used to eliminate a nuisance we’ve had when trying to insert and delete items in linked lists. For simplicity, we’ll consider lists of integers, built using this structure:
struct node { int data; struct node *next; }; Suppose we’re trying to write some code to delete a given integer from a list. The straightforward solution looks like this:
//delete node containing i from list pointed to by lp struct node *lp, *prevlp; for(lp = list; lp != NULL; lp = lp->next) { if(lp->item == i) { if(lp == list) list = lp->next; else { prevlp->next = lp->next; } break; } prevlp = lp; } This code works, but it has two flaws. One is that it must use an extra variable to keep track of the node behind the one it’s looking at, and the other is that it must use an extra test to special-case the situation in which the node being deleted is at the head of the list. Both problems arise because the deletion of a node from the list involves modifying the previous pointer to point to the next node (that is, the node before the deleted node to point to the one following). But, depending on whether the node being deleted is the first node in the list or not, the pointer that needs modifying is either the pointer that points to the head of the list, or the next pointer in the previous node.</description><generator>Hugo</generator><language>en-us</language><lastBuildDate/><atom:link href="https://textbooks.cs.ksu.edu/cis308/4-chapter/4_7-ptrstoptrs_linkedlists/index.xml" rel="self" type="application/rss+xml"/></channel></rss>