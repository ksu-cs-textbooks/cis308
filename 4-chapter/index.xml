<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Structs :: CIS 308 Textbook</title><link>https://textbooks.cs.ksu.edu/cis308/4-chapter/index.html</link><description/><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 27 Jun 2024 14:09:49 -0500</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cis308/4-chapter/index.xml" rel="self" type="application/rss+xml"/><item><title>Struct Syntax</title><link>https://textbooks.cs.ksu.edu/cis308/4-chapter/4_1-structsyntax/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/4-chapter/4_1-structsyntax/index.html</guid><description>C is a procedural programming language, which means that a program is just a collection of functions – no classes. However, C does have a construct called a struct that is similar to a data class in Java. A struct is simply a new variable type that is a collection of related data.
Syntax Here is the format of a struct declaration:
struct name { type1 name1; type2 name2; ... } objList; Here, name is the optional name for this structure type. This name is needed if you plan to created any variables of this struct type. The type name elements are fields that you want in your struct. For example, if the struct represented a person, you might want these fields:</description></item><item><title>Struct Example</title><link>https://textbooks.cs.ksu.edu/cis308/4-chapter/4_2-structexample/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/4-chapter/4_2-structexample/index.html</guid><description>Structs can be declared at any point in a C program, but they are usually declared with the global variables (right after the include statements). This way, the struct type can be used throughout the file.
Here is an example that uses a struct to store a two-dimensional point (x, y location). It gets two points as input, and then prints the equation that passes through the points.
#include &lt;stdio.h> struct point { int x; int y; }; //No variables declared here double getSlope(int, int, int, int); double getIntercept(int, int, double); int main() { struct point p1; struct point p2; double slope; double intercept; printf("Enter point1, e.g. (1, 2): "); scanf("(%d, %d)", &amp;(p1.x), &amp;(p1.y)); printf("Enter point2, e.g. (1, 2): "); scanf("(%d, %d)", &amp;(p2.x), &amp;(p2.y)); slope = getSlope(p1.x, p1.y, p2.x, p2.y); intercept = getIntercept(p1.x, p1.y, slope); //prints equation in form y = mx + b //m: slope, b: y-intercept printf("y = %.2lfx + %.2lf\n", slope, intercept); return 0; } double getSlope(int x1, int x2, int y1, int y2) { //slope = change in y / change in x return (y2-y1)/(x2-x1); } double getIntercept(int x, int y, double slope) { //if y = mx + b, b = y - mx return y - slope*x; }</description></item><item><title>Structs and Functions</title><link>https://textbooks.cs.ksu.edu/cis308/4-chapter/4_3-structsandfunctions/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/4-chapter/4_3-structsandfunctions/index.html</guid><description>We could have also written the point example by passing the point structs to the getSlope and getIntercept functions (instead of passing their fields). This works just like passing other variable types, except struct point will be an argument type. Here’s the example when we pass the points to the functions:
#include &lt;stdio.h> struct point { int x; int y; }; //No variables declared here double getSlope(struct point, struct point); double getIntercept(struct point, double); int main() { struct point p1; struct point p2; double slope; double intercept; printf("Enter point1, e.g. (1, 2): "); scanf("(%d, %d)", &amp;(p1.x), &amp;(p1.y)); printf("Enter point2, e.g. (1, 2): "); scanf("(%d, %d)", &amp;(p2.x), &amp;(p2.y)); slope = getSlope(p1, p2); intercept = getIntercept(p1, slope); //prints equation in form y = mx + b //m: slope, b: y-intercept printf("y = %.2lfx + %.2lf\n", slope, intercept); return 0; } double getSlope(struct point p1, struct point p2) { //slope = change in y / change in x return (p2.y-p1.y)/(p2.x-p1.x); } double getIntercept(struct point p, double slope) { //if y = mx + b, b = y - mx return p.y - slope*p.x; }</description></item><item><title>Arrays of Structs</title><link>https://textbooks.cs.ksu.edu/cis308/4-chapter/4_4-arraysofstructs/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/4-chapter/4_4-arraysofstructs/index.html</guid><description>You can create arrays of structs in C just like you can create arrays of any other type. The format for creating constant-sized arrays is:
type name[size]; Consider the person struct again:
struct person { char name[20]; int age; }; Here’s how to create a 3-slot array of type struct person called group:
//"struct person" is the type; "group" is the array name struct person group[3]; When you create an array of type struct, C allocates space for each struct element (and its fields) in the array.</description></item><item><title>Pointers to Structs</title><link>https://textbooks.cs.ksu.edu/cis308/4-chapter/4_5-pointerstostructs/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/4-chapter/4_5-pointerstostructs/index.html</guid><description>You can declare a pointer to a struct just like you declare a pointer to another element type. The format for declaring a pointer is:
type* name; So, to declare a pointer to a struct person element, we could say:
struct person* personPtr; Suppose we have another struct person variable:
struct person p1; strcpy(p1.name, "Jill"); p1.age = 18; Then we can make personPtr point to p1:
personPtr = &amp;p1; Allocating Memory We can also create struct variables by:</description></item><item><title>Linked Lists</title><link>https://textbooks.cs.ksu.edu/cis308/4-chapter/4_6-linkedlists/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/4-chapter/4_6-linkedlists/index.html</guid><description>We can use structs to help implement all the common data structures in C. For example, whereas before we would have created a Node class to help us write a linked list, we will now create a node struct:
struct node { int data; struct node *next; //pointer to next node in list }; Suppose we want to create a linked list with a single node. First, we declare a head variable:</description></item><item><title>Pointers to Pointers in Linked Lists</title><link>https://textbooks.cs.ksu.edu/cis308/4-chapter/4_7-ptrstoptrs_linkedlists/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/4-chapter/4_7-ptrstoptrs_linkedlists/index.html</guid><description>Let’s look at how pointers to pointers can be used to eliminate a nuisance we’ve had when trying to insert and delete items in linked lists. For simplicity, we’ll consider lists of integers, built using this structure:
struct node { int data; struct node *next; }; Suppose we’re trying to write some code to delete a given integer from a list. The straightforward solution looks like this:
//delete node containing i from list pointed to by lp struct node *lp, *prevlp; for(lp = list; lp != NULL; lp = lp->next) { if(lp->item == i) { if(lp == list) list = lp->next; else { prevlp->next = lp->next; } break; } prevlp = lp; } This code works, but it has two flaws. One is that it must use an extra variable to keep track of the node behind the one it’s looking at, and the other is that it must use an extra test to special-case the situation in which the node being deleted is at the head of the list. Both problems arise because the deletion of a node from the list involves modifying the previous pointer to point to the next node (that is, the node before the deleted node to point to the one following). But, depending on whether the node being deleted is the first node in the list or not, the pointer that needs modifying is either the pointer that points to the head of the list, or the next pointer in the previous node.</description></item></channel></rss>