<!doctype html><html lang=en-us dir=ltr itemscope itemtype=http://schema.org/Article data-r-output-format=html><head><meta charset=utf-8><meta name=viewport content="height=device-height,width=device-width,initial-scale=1,minimum-scale=1"><meta name=generator content="Hugo 0.148.1"><meta name=generator content="Relearn 8.0.0"><meta name=description content="It gets a bit cumbersome to use types called struct person and enum grade. It would be much nicer to be able to call them just person or grade. With C’s typedef construct, we can do just that.
The format of typedef is:
typedef oldType newType; Here, we rename type oldType to the new name newType. We can now create variables using the name newType. For example:
typedef char letterGrade; letterGrade g; g = 'A'; Notice that we treat our new letterGrade type just like it was a char. The only difference is that when we declare the variable, we can use letterGrade as the type instead of char."><meta name=author content="Julie Thornton"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://textbooks.cs.ksu.edu/cis308/images/hero.png"><meta name=twitter:title content="typedef :: CIS 308 Textbook"><meta name=twitter:description content="It gets a bit cumbersome to use types called struct person and enum grade. It would be much nicer to be able to call them just person or grade. With C’s typedef construct, we can do just that.
The format of typedef is:
typedef oldType newType; Here, we rename type oldType to the new name newType. We can now create variables using the name newType. For example:
typedef char letterGrade; letterGrade g; g = 'A'; Notice that we treat our new letterGrade type just like it was a char. The only difference is that when we declare the variable, we can use letterGrade as the type instead of char."><meta property="og:url" content="https://textbooks.cs.ksu.edu/cis308/6-chapter/6_3-typedef/index.html"><meta property="og:site_name" content="CIS 308 Textbook"><meta property="og:title" content="typedef :: CIS 308 Textbook"><meta property="og:description" content="It gets a bit cumbersome to use types called struct person and enum grade. It would be much nicer to be able to call them just person or grade. With C’s typedef construct, we can do just that.
The format of typedef is:
typedef oldType newType; Here, we rename type oldType to the new name newType. We can now create variables using the name newType. For example:
typedef char letterGrade; letterGrade g; g = 'A'; Notice that we treat our new letterGrade type just like it was a char. The only difference is that when we declare the variable, we can use letterGrade as the type instead of char."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="User-Defined Types"><meta property="article:published_time" content="2018-08-24T10:53:26-05:00"><meta property="article:modified_time" content="2022-09-28T11:30:45-05:00"><meta property="og:image" content="https://textbooks.cs.ksu.edu/cis308/images/hero.png"><meta itemprop=name content="typedef :: CIS 308 Textbook"><meta itemprop=description content="It gets a bit cumbersome to use types called struct person and enum grade. It would be much nicer to be able to call them just person or grade. With C’s typedef construct, we can do just that.
The format of typedef is:
typedef oldType newType; Here, we rename type oldType to the new name newType. We can now create variables using the name newType. For example:
typedef char letterGrade; letterGrade g; g = 'A'; Notice that we treat our new letterGrade type just like it was a char. The only difference is that when we declare the variable, we can use letterGrade as the type instead of char."><meta itemprop=datePublished content="2018-08-24T10:53:26-05:00"><meta itemprop=dateModified content="2022-09-28T11:30:45-05:00"><meta itemprop=wordCount content="521"><meta itemprop=image content="https://textbooks.cs.ksu.edu/cis308/images/hero.png"><title>typedef :: CIS 308 Textbook</title><link href=https://textbooks.cs.ksu.edu/cis308/6-chapter/6_3-typedef/index.html rel=canonical type=text/html title="typedef :: CIS 308 Textbook"><link href=/cis308/6-chapter/6_3-typedef/index.xml rel=alternate type=application/rss+xml title="typedef :: CIS 308 Textbook"><link href=/cis308/6-chapter/6_3-typedef/index.print.html rel=alternate type=text/html title="typedef :: CIS 308 Textbook"><link href=/cis308/6-chapter/6_3-typedef/embed.html rel=alternate type=text/html title="typedef :: CIS 308 Textbook"><link href=/cis308/css/auto-complete/auto-complete.min.css?1755623839 rel=stylesheet><script src=/cis308/js/auto-complete/auto-complete.min.js?1755623839 defer></script><script src=/cis308/js/search-lunr.min.js?1755623839 defer></script><script src=/cis308/js/search.min.js?1755623839 defer></script><script>window.relearn=window.relearn||{},window.relearn.index_js_url="/cis308/searchindex.en.js?1755623839"</script><script src=/cis308/js/lunr/lunr.min.js?1755623839 defer></script><script src=/cis308/js/lunr/lunr.stemmer.support.min.js?1755623839 defer></script><script src=/cis308/js/lunr/lunr.multi.min.js?1755623839 defer></script><script src=/cis308/js/lunr/lunr.en.min.js?1755623839 defer></script><script>window.relearn=window.relearn||{},window.relearn.contentLangs=["en"]</script><link href=/cis308/fonts/fontawesome/css/fontawesome-all.min.css?1755623839 rel=stylesheet media=print onload='this.media="all",this.onload=null'><noscript><link href=/cis308/fonts/fontawesome/css/fontawesome-all.min.css?1755623839 rel=stylesheet></noscript><link href=/cis308/css/perfect-scrollbar/perfect-scrollbar.min.css?1755623839 rel=stylesheet><link href=/cis308/css/theme.min.css?1755623839 rel=stylesheet><link href=/cis308/css/format-html.min.css?1755623839 rel=stylesheet id=R-format-style><script>window.relearn=window.relearn||{},window.relearn.min=`.min`,window.relearn.path="/6-chapter/6_3-typedef/index.html",window.relearn.relBasePath="../..",window.relearn.relBaseUri="../../..",window.relearn.absBaseUri="https://textbooks.cs.ksu.edu/cis308",window.relearn.disableAnchorCopy=!1,window.relearn.disableAnchorScrolling=!1,window.relearn.disableInlineCopyToClipboard=!0,window.relearn.enableBlockCodeWrap=!1,window.relearn.getItem=(e,t)=>e.getItem(t),window.relearn.setItem=(e,t,n)=>e.setItem(t,n),window.relearn.removeItem=(e,t)=>e.removeItem(t),window.T_Copy_to_clipboard=`Copy to clipboard`,window.T_Copied_to_clipboard=`Copied to clipboard!`,window.T_Copy_link_to_clipboard=`Copy link to clipboard`,window.T_Link_copied_to_clipboard=`Copied link to clipboard!`,window.T_Reset_view=`Reset view`,window.T_View_reset=`View reset!`,window.T_No_results_found=`No results found for "{0}"`,window.T_N_results_found=`{1} results found for "{0}"`,window.relearn.themevariants=["light-theme"],window.relearn.customvariantname="my-custom-variant",window.relearn.writeVariant=!1,window.relearn.changeVariant=function(e){var t=document.documentElement.dataset.rThemeVariant;window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e),document.documentElement.dataset.rThemeVariant=e,t!=e&&(document.dispatchEvent(new CustomEvent("themeVariantLoaded",{detail:{variant:e,oldVariant:t}})),window.relearn.markVariant())},window.relearn.markVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant");document.querySelectorAll(".R-variantswitcher select").forEach(t=>{t.value=e})},window.relearn.initVariant=function(){var e=window.relearn.getItem(window.localStorage,window.relearn.absBaseUri+"/variant")??"";e==window.relearn.customvariantname||(!e||!window.relearn.themevariants.includes(e))&&(e=window.relearn.themevariants[0],window.relearn.writeVariant&&window.relearn.setItem(window.localStorage,window.relearn.absBaseUri+"/variant",e)),document.documentElement.dataset.rThemeVariant=e},window.relearn.initVariant(),window.relearn.markVariant()</script><link href=/cis308/css/custom.css?1755623839 rel=stylesheet></head><body class="mobile-support html" data-url=/cis308/6-chapter/6_3-typedef/index.html><div id=tele class="tele mirror"><div id=R-body class=default-animation><div id=R-body-overlay></div><div id=R-main-overlay></div><main id=R-body-inner class="highlightable 6-chapter" tabindex=-1><div class=flex-block-wrapper><article class=default><header class=headline></header><h1 id=typedef>typedef</h1><p>It gets a bit cumbersome to use types called <code>struct person</code>
and <code>enum grade</code>. It would be much nicer to be able to call
them just <code>person</code> or <code>grade</code>. With C&rsquo;s typedef construct, we
can do just that.</p><p>The format of typedef is:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>typedef oldType newType;</span></span></code></pre></div><p>Here, we rename <code>type oldType</code> to the new name <code>newType</code>. We
can now create variables using the name <code>newType</code>. For example:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>char</span> letterGrade;
</span></span><span style=display:flex><span>letterGrade g;
</span></span><span style=display:flex><span>g <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;A&#39;</span>;</span></span></code></pre></div><p>Notice that we treat our new <code>letterGrade</code> type just like it was a
char. The only difference is that when we declare the variable, we
can use <code>letterGrade</code> as the type instead of char.</p><h2 id=typedef-with-structs-unions-and-enums>Typedef with Structs, Unions, and Enums</h2><p>We can do a similar thing to rename structs, unions, and
enums. For example, consider the following struct:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>};</span></span></code></pre></div><p>The formal type of the struct is <code>struct person</code>. Now, we
want to rename the type to be just <code>person</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>//typedef oldType newType
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> person person;  
</span></span></code></pre></div><p>Alternatively, we can declare the struct and rename it with typedef
all on the same line:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>//typedef oldType newType
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> person {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>} person;</span></span></code></pre></div><p>However, we don&rsquo;t need to name the struct now, since we&rsquo;re
always going to be using the new type name when creating
variables of this type:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> name[<span style=color:#ae81ff>20</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> age;
</span></span><span style=display:flex><span>} person;</span></span></code></pre></div><p>Now we can declare and use a <code>person</code> variable:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>person p;
</span></span><span style=display:flex><span><span style=color:#a6e22e>strcpy</span>(p.name, <span style=color:#e6db74>&#34;Bill&#34;</span>);
</span></span><span style=display:flex><span>p.age <span style=color:#f92672>=</span> <span style=color:#ae81ff>22</span>;</span></span></code></pre></div><p>We can do a similar thing to rename unions and enums. Consider
the following union:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>union</span> money {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> dollars;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> yen;
</span></span><span style=display:flex><span>};</span></span></code></pre></div><p>We can rename the union type to <code>money</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>union</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> dollars;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> yen;
</span></span><span style=display:flex><span>} money;</span></span></code></pre></div><p>Now we can use <code>money</code> as the type name instead of <code>union money</code>. Similarly, consider the following enum:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>enum</span> grade{freshman <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>, sophomore, junior, senior};</span></span></code></pre></div><p>We can rename the enum type to <code>grade</code>:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> {freshman <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>, sophomore, junior, senior} grade;</span></span></code></pre></div><p>Now we can use <code>grade</code> as the type name instead of <code>enum grade</code>.</p><h2 id=typedef-with-linked-lists>Typedef with Linked Lists</h2><p>Consider the following structure for a node in a linked list:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> node {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>};</span></span></code></pre></div><p>We can try to rename the <code>struct node</code> type to <code>node</code> using
typedef:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data;
</span></span><span style=display:flex><span>    node <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>} node;</span></span></code></pre></div><p>However, this will give us a compiler error. The reason is that this
struct is self-referential. When we declare the field <code>node *next</code> in the struct, the compiler hasn&rsquo;t yet seen that we&rsquo;re
renaming the type to <code>node</code>. If instead we list the field as:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>next;</span></span></code></pre></div><p>we will also get a complaint, as we left off the name of the struct.
If you&rsquo;re using typedef on a self-referential struct, you need to
include BOTH the name of the struct and the name of the renamed
type. The fixed node struct looks like:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> node {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> data;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>} node;</span></span></code></pre></div><p>Here&rsquo;s how we&rsquo;d use it:</p><div class=highlight dir=auto><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>node <span style=color:#f92672>*</span>head <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(node));
</span></span><span style=display:flex><span>head<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span>head<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(node));
</span></span><span style=display:flex><span>head<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>head<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> NULL;</span></span></code></pre></div><p>This creates the linked list 4->7.</p><footer class=footline></footer></article></div></main></div><script src=/cis308/js/clipboard/clipboard.min.js?1755623839 defer></script><script src=/cis308/js/perfect-scrollbar/perfect-scrollbar.min.js?1755623839 defer></script><script src=/cis308/js/theme.min.js?1755623839 defer></script></div><script src=/cis308/js/tele-scroll.min.js?1755623839 defer></script></body></html>