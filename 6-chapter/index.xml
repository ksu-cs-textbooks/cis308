<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>User-Defined Types :: CIS 308 Textbook</title><link>https://textbooks.cs.ksu.edu/cis308/6-chapter/index.html</link><description/><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 28 Sep 2022 11:30:45 -0500</lastBuildDate><atom:link href="https://textbooks.cs.ksu.edu/cis308/6-chapter/index.xml" rel="self" type="application/rss+xml"/><item><title>Enums</title><link>https://textbooks.cs.ksu.edu/cis308/6-chapter/6_1-enum/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/6-chapter/6_1-enum/index.html</guid><description>enum provides a way to create integer constants. For instance, in Java we might declare:
public static final int GOLD = 1; public static final int SILVER = 2; public static final int BRONZE = 3; ..but really what we want is to create a “medal” type that can take on the values GOLD, SILVER, and BRONZE. Moreover, we want GOLD to mean “1”, SILVER to mean “2”, and BRONZE to mean “3”.
(Note: Java does have enums available in its latest version, which are handled very similarly to how they are in C.)</description></item><item><title>Unions</title><link>https://textbooks.cs.ksu.edu/cis308/6-chapter/6_2-union/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/6-chapter/6_2-union/index.html</guid><description>A union is a construct in C that can hold one of several types. A union variable can only hold one value at a time, unlike a struct, but that value is not restricted to a single type.
Here’s the format for declaring a union:
union modelName { type1 name1; type2 name2; ... typeN nameN; } objectList; Here, modelName is the name of the type you’re creating, each type name is a type you want to be able to store in this union plus a name for it, and objectList is a list of variables you want to create with this union type. Both modelName and objectList are optional.</description></item><item><title>typedef</title><link>https://textbooks.cs.ksu.edu/cis308/6-chapter/6_3-typedef/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/6-chapter/6_3-typedef/index.html</guid><description>It gets a bit cumbersome to use types called struct person and enum grade. It would be much nicer to be able to call them just person or grade. With C’s typedef construct, we can do just that.
The format of typedef is:
typedef oldType newType; Here, we rename type oldType to the new name newType. We can now create variables using the name newType. For example:
typedef char letterGrade; letterGrade g; g = 'A'; Notice that we treat our new letterGrade type just like it was a char. The only difference is that when we declare the variable, we can use letterGrade as the type instead of char.</description></item><item><title>User-Defined Types with Pointers</title><link>https://textbooks.cs.ksu.edu/cis308/6-chapter/6_4-usertypes_w_ptrs/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/6-chapter/6_4-usertypes_w_ptrs/index.html</guid><description>Consider the following struct:
typedef struct { char name[20]; int age; union { struct { char major[20]; double gpa; } student; struct { char division[20]; int yearsWorked; } employee; } type; enum {employeeK, studentK} typeK; } person; Suppose we want to create a pointer to a struct variable with the following information:
Name: Bob Jones Student Age: 18 Major: EECE GPA: 3.2 First, we’d declare a pointer of type person:</description></item><item><title>Preprocessor Directives</title><link>https://textbooks.cs.ksu.edu/cis308/6-chapter/6_5-preprocessor/index.html</link><pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate><guid>https://textbooks.cs.ksu.edu/cis308/6-chapter/6_5-preprocessor/index.html</guid><description>The C pre-processor is a special program that runs before the C compiler. It processes every line that begins with a #, such as a #include statement. The pre-processor may add, remove, or change your code when handling the # statements.
#include We’ve been using the #include statement since our first program in order to get access to C’s library functions (like printf in stdio.h). When the pre-processor sees a #include statement, it replaces the #include line with the contents of the included file. For example, when the pre-processor sees:</description></item></channel></rss>